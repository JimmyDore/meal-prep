---
phase: 05-macro-calculation-engine
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/nutrition/unit-conversion.ts
  - src/lib/nutrition/recipe-macros.ts
  - src/lib/nutrition/__tests__/unit-conversion.test.ts
  - src/lib/nutrition/__tests__/recipe-macros.test.ts
autonomous: true

must_haves:
  truths:
    - "convertToGrams converts all French cooking units (Kilogramme, Litre, Cuillere, Piece, etc.) to grams"
    - "convertToGrams looks up ingredient-specific weights for Piece unit with accent-stripped matching"
    - "calculateRecipeMacros sums ingredient macros and divides by portions to get per-serving values"
    - "calculateRecipeMacros returns confidence score based on percentage of successfully converted ingredients"
    - "Missing or unconvertible ingredients are tracked in missingIngredients array"
  artifacts:
    - path: "src/lib/nutrition/unit-conversion.ts"
      provides: "Unit-to-grams conversion"
      exports: ["convertToGrams"]
    - path: "src/lib/nutrition/recipe-macros.ts"
      provides: "Per-serving macro calculation"
      exports: ["calculateRecipeMacros"]
    - path: "src/lib/nutrition/__tests__/unit-conversion.test.ts"
      provides: "Unit conversion tests"
      min_lines: 60
    - path: "src/lib/nutrition/__tests__/recipe-macros.test.ts"
      provides: "Recipe macros tests"
      min_lines: 60
  key_links:
    - from: "src/lib/nutrition/recipe-macros.ts"
      to: "src/lib/nutrition/unit-conversion.ts"
      via: "imports convertToGrams"
      pattern: "import.*convertToGrams.*unit-conversion"
---

<objective>
Build the unit conversion table and per-serving recipe macro calculator with comprehensive tests.

Purpose: Enables computing real macros per portion for any recipe by converting ingredient quantities from French cooking units to grams, then applying macros-per-100g data. This is independent of the user's TDEE/targets -- it's about recipe data quality.
Output: Two source files (unit-conversion.ts, recipe-macros.ts) and two test files.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-macro-calculation-engine/05-RESEARCH.md

@src/db/schema/ingredients.ts
@src/db/schema/recipes.ts
@src/db/queries/recipes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create unit conversion module with tests</name>
  <files>
    src/lib/nutrition/unit-conversion.ts
    src/lib/nutrition/__tests__/unit-conversion.test.ts
  </files>
  <action>
Create `src/lib/nutrition/unit-conversion.ts` with:

1. `UNIT_TO_GRAMS` record mapping French unit names to gram equivalents:
   - Kilogramme: 1000, Litre: 1000
   - "Cuillere a soupe": 15, "Cuillere a cafe": 5 (NOTE: check the exact unit strings stored in the DB -- they may have accents like "Cuillere a soupe" or "Cuillere a cafe" or use different casing. Include both accented and unaccented variants if needed.)
   - Gousse: 5, Bouquet: 25, Brin: 2, Pincee: 0.5
   - Noisette: 5, Poignee: 30, Tranche: 30, Boule: 60
   - Centimetre: 5, Sachet: 10, Quartier: 30, Portion: 100, Leaf: 1

2. `PIECE_WEIGHTS` record mapping lowercase accent-stripped ingredient name fragments to grams per piece. Include all items from the research:
   - Eggs/dairy: oeuf 55, petit suisse 60, mozzarella 125, yaourt 125
   - Vegetables: oignon 100, echalote 25, tomate 130, tomate cerise 15, pomme de terre 140, carotte 125, courgette 200, aubergine 300, poivron 150, concombre 200, avocat 200, ail 5
   - Fruits: citron 120, citron vert 100, pomme 150, poire 120, orange 200, banane 150, abricot 45, peche 150, kiwi 100, mangue 400
   - Meat/other: escalope 150, filet 150, saucisse 100, tortilla 50, galette 50

3. `DEFAULT_PIECE_WEIGHT` = 100 (fallback for unknown pieces)

4. Export function `convertToGrams(quantity: number, unit: string | null, ingredientName: string): number | null`
   - If unit is null, return null
   - If unit is "Piece" (or "Piece" -- check DB casing): look up in PIECE_WEIGHTS using normalized ingredient name (lowercase, accent-stripped via NFD + regex)
   - Try each PIECE_WEIGHTS key as a substring match against the normalized name
   - If no match found, use DEFAULT_PIECE_WEIGHT
   - For non-Piece units: look up in UNIT_TO_GRAMS, return quantity * factor, or null if unit not found

Create `src/lib/nutrition/__tests__/unit-conversion.test.ts` with test cases:

**Direct unit conversions:**
- 0.15 Kilogramme -> 150g
- 2 Litre -> 2000g
- 3 "Cuillere a soupe" -> 45g
- 1 "Cuillere a cafe" -> 5g
- 2 Gousse -> 10g
- 1 Pincee -> 0.5g

**Piece lookups (accent-stripped matching):**
- 2 Piece of "Oeuf" -> 110g (2 * 55)
- 1 Piece of "Oignon jaune" -> 100g
- 3 Piece of "Tomates cerises" -> 45g (3 * 15, matches "tomate cerise")
- 1 Piece of "Pomme de terre" -> 140g
- 1 Piece of "Citron vert" -> 100g (not matched by "citron" = 120g, matched by "citron vert" = 100g)

**Important:** Order PIECE_WEIGHTS entries so more specific keys (like "citron vert") are checked before less specific ones (like "citron"). Use an array of [key, value] tuples sorted by key length descending, or iterate longest-first.

**Unknown piece fallback:**
- 1 Piece of "SomeUnknownIngredient" -> 100g (DEFAULT_PIECE_WEIGHT)

**Unknown unit:**
- 1 "UnknownUnit" of anything -> null

**Null unit:**
- null unit -> null

**Accented ingredient names:**
- "Echalote" (with accent) should still match "echalote" after normalization
  </action>
  <verify>Run `pnpm test src/lib/nutrition/__tests__/unit-conversion.test.ts` -- all tests pass.</verify>
  <done>convertToGrams handles all 18 French cooking units, piece lookups with accent stripping, and returns null for unknown units. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create recipe macros calculator with tests</name>
  <files>
    src/lib/nutrition/recipe-macros.ts
    src/lib/nutrition/__tests__/recipe-macros.test.ts
  </files>
  <action>
Create `src/lib/nutrition/recipe-macros.ts`:

Define an `IngredientInput` interface (local to this file, not exported from types.ts):
```typescript
interface IngredientInput {
  name: string;
  quantity: number | null;
  unit: string | null;
  caloriesPer100g: number | null;
  proteinPer100g: number | null;
  carbsPer100g: number | null;
  fatPer100g: number | null;
}
```

Export function `calculateRecipeMacros(ingredients: IngredientInput[], originalPortions: number): RecipeMacrosResult`:

1. For each ingredient:
   - Skip if quantity is null OR caloriesPer100g is null (add to missingIngredients)
   - Convert quantity+unit to grams via `convertToGrams()`
   - If conversion returns null, add to missingIngredients and skip
   - Calculate: factor = grams / 100, then multiply each macro by factor
   - Accumulate totals

2. Divide totals by `originalPortions` (default to 1 if 0 or negative) for per-serving values

3. Calculate confidence:
   - convertedCount / totalCount >= 0.9 -> "high"
   - >= 0.7 -> "medium"
   - < 0.7 -> "low"

4. Round all macro values to nearest integer with Math.round()

Import `convertToGrams` from `./unit-conversion` and `RecipeMacrosResult` from `./types`.

Create `src/lib/nutrition/__tests__/recipe-macros.test.ts` with test cases:

**Basic recipe (2 ingredients, 4 portions):**
```
Ingredient 1: 0.5 Kilogramme chicken (cal 165, protein 31, carbs 0, fat 3.6 per 100g)
  -> 500g -> factor 5 -> 825 cal, 155g protein, 0g carbs, 18g fat
Ingredient 2: 0.3 Kilogramme rice (cal 130, protein 2.7, carbs 28, fat 0.3 per 100g)
  -> 300g -> factor 3 -> 390 cal, 8.1g protein, 84g carbs, 0.9g fat
Total: 1215 cal, 163.1g protein, 84g carbs, 18.9g fat
Per serving (4): 304 cal, 41g protein, 21g carbs, 5g fat
Confidence: high (2/2 = 100%)
```

**Recipe with missing ingredient macro data:**
- 3 ingredients, one has null caloriesPer100g
- convertedCount should be 2, totalCount 3
- missingIngredients should contain the name of the null-macro ingredient

**Recipe with unknown unit:**
- 1 ingredient with unit "SomeWeirdUnit" -> added to missingIngredients
- Confidence adjusted accordingly

**Recipe with null quantity:**
- Ingredient with null quantity is skipped

**Recipe with 0 portions:**
- originalPortions = 0 -> treated as 1

**Confidence thresholds:**
- 10/10 ingredients -> "high"
- 8/10 ingredients -> "medium"  (0.8 >= 0.7)
- 5/10 ingredients -> "low" (0.5 < 0.7)

**Empty ingredients array:**
- Returns all zeros, confidence "low" (0/0 edge case -- handle division by zero: if no ingredients, confidence is "low")
  </action>
  <verify>Run `pnpm test src/lib/nutrition/__tests__/recipe-macros.test.ts` -- all tests pass.</verify>
  <done>calculateRecipeMacros correctly computes per-serving macros with confidence scoring. Handles missing data, unknown units, null quantities, zero portions. All tests pass.</done>
</task>

</tasks>

<verification>
1. `pnpm exec tsc --noEmit` -- no type errors
2. `pnpm test src/lib/nutrition/__tests__/unit-conversion.test.ts` -- all tests pass
3. `pnpm test src/lib/nutrition/__tests__/recipe-macros.test.ts` -- all tests pass
4. `pnpm check` -- Biome formatting/linting passes
</verification>

<success_criteria>
- convertToGrams handles all 18 French cooking units from the research
- Piece unit does ingredient-specific weight lookup with accent stripping
- calculateRecipeMacros computes per-serving and total macros from ingredient data
- Confidence score accurately reflects data quality (high/medium/low)
- Missing ingredients are tracked and reported
- All tests pass with `pnpm test`
</success_criteria>

<output>
After completion, create `.planning/phases/05-macro-calculation-engine/05-02-SUMMARY.md`
</output>
