---
phase: 01-project-foundation-database-deployment
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - vitest.config.mts
  - src/test/setup.ts
  - src/test/db-setup.ts
  - src/lib/__tests__/env.test.ts
  - src/db/__tests__/connection.test.ts
autonomous: true

must_haves:
  truths:
    - "pnpm test run executes all tests and reports results"
    - "Unit tests run in jsdom environment without database"
    - "Integration tests connect to isolated test Postgres (port 5434)"
    - "Test database is separate from dev database"
  artifacts:
    - path: "vitest.config.mts"
      provides: "Vitest configuration with jsdom, globals, React plugin"
      contains: "jsdom"
    - path: "src/test/setup.ts"
      provides: "Global test setup file"
      min_lines: 5
    - path: "src/test/db-setup.ts"
      provides: "Test database connection and cleanup utilities"
      contains: "5434"
    - path: "src/lib/__tests__/env.test.ts"
      provides: "Smoke test proving Vitest works"
      contains: "describe"
    - path: "src/db/__tests__/connection.test.ts"
      provides: "Integration test proving DB test connection works"
      contains: "SELECT"
  key_links:
    - from: "vitest.config.mts"
      to: "src/test/setup.ts"
      via: "setupFiles config"
      pattern: "setupFiles.*setup"
    - from: "src/db/__tests__/connection.test.ts"
      to: "src/test/db-setup.ts"
      via: "test DB import"
      pattern: "import.*db-setup"
---

<objective>
Set up the complete test infrastructure: Vitest configuration, test database utilities, and initial smoke tests proving both unit and integration testing work.

Purpose: Every subsequent phase writes tests. The test infrastructure must be solid from day one -- isolated test DB, proper setup/teardown, and working Vitest config.
Output: Vitest configured and running, test DB utilities, at least 2 passing tests (1 unit, 1 integration).
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation-database-deployment/01-RESEARCH.md
@.planning/phases/01-project-foundation-database-deployment/01-CONTEXT.md

# Need to know project structure and installed packages
@.planning/phases/01-project-foundation-database-deployment/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure Vitest and create test utilities</name>
  <files>
    vitest.config.mts
    src/test/setup.ts
    src/test/db-setup.ts
  </files>
  <action>
    1. Create `vitest.config.mts`:
    - Import defineConfig from "vitest/config"
    - Import react from "@vitejs/plugin-react"
    - Import tsconfigPaths from "vite-tsconfig-paths"
    - Plugins: [tsconfigPaths(), react()]
    - test.environment: "jsdom"
    - test.globals: true (enables describe/it/expect without imports)
    - test.include: ["src/**/*.test.{ts,tsx}"]
    - test.setupFiles: ["./src/test/setup.ts"]
    - test.exclude: ["node_modules", ".next"]
    (See exact pattern in RESEARCH.md "Vitest Configuration")

    2. Create `src/test/setup.ts`:
    - Import "@testing-library/jest-dom" (if available) or add a comment placeholder
    - Add any global test setup (e.g., afterEach cleanup)
    - For now, keep it minimal -- just ensure the file exists and is importable
    - Export nothing (side-effect only file)

    3. Create `src/test/db-setup.ts` -- test database utilities:
    - Create a test Drizzle client connecting to the TEST database (port 5434):
      ```
      DATABASE_URL=postgresql://mealprep_test:mealprep_test@localhost:5434/mealprep_test
      ```
    - Do NOT use @t3-oss/env-nextjs here -- hardcode the test URL or use process.env.DATABASE_TEST_URL
    - Export: `testDb` (Drizzle instance), `testClient` (postgres.js client)
    - Export a `cleanupTestDb` function that truncates all tables (for use in beforeEach/afterAll)
    - Export a `closeTestDb` function that closes the postgres.js connection (for use in afterAll)
    - Import schema from src/db/schema to bind it to testDb with casing: "snake_case"

    IMPORTANT: The test DB client must connect to port 5434 (the test Postgres from docker-compose.yml), NOT port 5433 (dev database). This keeps test data completely isolated.
  </action>
  <verify>
    - `vitest.config.mts` exists and TypeScript compiles it without errors
    - `src/test/setup.ts` exists
    - `src/test/db-setup.ts` exports testDb, cleanupTestDb, closeTestDb
  </verify>
  <done>Vitest configured with jsdom environment, React plugin, and path aliases. Test DB utilities ready for integration tests with isolated test Postgres on port 5434.</done>
</task>

<task type="auto">
  <name>Task 2: Create smoke tests for unit and integration testing</name>
  <files>
    src/lib/__tests__/env.test.ts
    src/db/__tests__/connection.test.ts
  </files>
  <action>
    1. Ensure Docker Compose test DB is running: `docker compose up -d db-test`

    2. Create `src/lib/__tests__/env.test.ts` -- a simple unit test:
    - Test that the test runner works: `describe("Environment", () => { it("should be test", () => { expect(1 + 1).toBe(2); }); })`
    - This is intentionally trivial -- the goal is proving Vitest config works

    3. Create `src/db/__tests__/connection.test.ts` -- an integration test:
    - Import testDb and closeTestDb from "@/test/db-setup"
    - `describe("Database Connection", () => { ... })`
    - Test: connect to test DB, run `SELECT NOW()`, verify result exists
    - Test: verify tables exist (query information_schema.tables for 'recipes')
    - afterAll: call closeTestDb() to cleanly close the connection
    - NOTE: This test requires Docker test DB to be running. If migrations haven't been run on test DB, run them first: the test should run `drizzle-kit migrate` against the test DB URL, OR the test should use `drizzle-kit push` to sync schema. Simplest approach: use push for test DB in the db-setup.ts file (call `migrate` or `push` in a beforeAll or in the db-setup module initialization).

    4. Add to `src/test/db-setup.ts` a function `setupTestDb` that runs migrations on the test database. Use `drizzle-kit push` via the Drizzle API or execute `migrate(testDb, { migrationsFolder: "./drizzle" })` from drizzle-orm/postgres-js/migrator. Call this in beforeAll of integration tests.

    5. Run `pnpm test run` and verify both tests pass.

    IMPORTANT: Integration tests need the test Docker DB running. Add a note in the test file: `// Requires: docker compose up -d db-test`
  </action>
  <verify>
    - `pnpm test run` passes with 2+ tests
    - Output shows both test files executed
    - Integration test successfully queries the test database
    - No tests touch the dev database (port 5433)
  </verify>
  <done>Vitest runs with at least 1 unit test and 1 integration test passing. Integration test connects to isolated test Postgres (port 5434), verifies connection and table existence. Test infrastructure is ready for all subsequent phases.</done>
</task>

</tasks>

<verification>
1. `pnpm test run` completes with all tests passing
2. Unit test runs without Docker dependency
3. Integration test connects to test DB on port 5434
4. Test DB is isolated from dev DB
5. Cleanup utilities work (tables can be truncated between tests)
</verification>

<success_criteria>
- Vitest configured with jsdom, React plugin, path aliases, globals
- Test DB utilities provide isolated Postgres connection
- At least 1 unit test and 1 integration test pass
- Test infrastructure ready for use by all future phases
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation-database-deployment/01-03-SUMMARY.md`
</output>
