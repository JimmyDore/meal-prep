---
phase: 01-project-foundation-database-deployment
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/db/schema/common.ts
  - src/db/schema/recipes.ts
  - src/db/schema/ingredients.ts
  - src/db/schema/tags.ts
  - src/db/schema/index.ts
  - src/db/index.ts
  - src/db/seed.ts
  - drizzle/
autonomous: true

must_haves:
  truths:
    - "drizzle-kit generate produces SQL migration files from schema"
    - "drizzle-kit migrate applies migrations to dev Postgres"
    - "Seed script populates tables with sample recipes, ingredients, and tags"
    - "Schema has recipes, ingredients, recipe_ingredients junction, tags, and recipe_tags junction tables"
  artifacts:
    - path: "src/db/schema/common.ts"
      provides: "Reusable id + timestamps columns"
      contains: "idColumn"
    - path: "src/db/schema/recipes.ts"
      provides: "recipes table definition"
      contains: "pgTable"
    - path: "src/db/schema/ingredients.ts"
      provides: "ingredients + recipe_ingredients tables"
      contains: "recipeIngredients"
    - path: "src/db/schema/tags.ts"
      provides: "tags + recipe_tags junction tables"
      contains: "recipeTags"
    - path: "src/db/schema/index.ts"
      provides: "Barrel export of all schema"
      exports: ["recipes", "ingredients", "recipeIngredients", "tags", "recipeTags"]
    - path: "src/db/seed.ts"
      provides: "Seed script with sample data"
      min_lines: 50
  key_links:
    - from: "src/db/schema/ingredients.ts"
      to: "src/db/schema/recipes.ts"
      via: "foreign key reference"
      pattern: "references.*recipes"
    - from: "src/db/schema/tags.ts"
      to: "src/db/schema/recipes.ts"
      via: "foreign key reference"
      pattern: "references.*recipes"
    - from: "src/db/index.ts"
      to: "src/db/schema/index.ts"
      via: "schema import"
      pattern: "import.*schema"
---

<objective>
Create the complete Postgres schema (recipes, ingredients, tags with junction tables), generate versioned migrations, and build a seed script with sample data.

Purpose: The database schema is the data foundation for the entire application. Recipes, ingredients, and tags are the core domain entities referenced by every subsequent phase.
Output: Drizzle schema files, generated SQL migrations in drizzle/, seed script with sample recipes.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation-database-deployment/01-RESEARCH.md
@.planning/phases/01-project-foundation-database-deployment/01-CONTEXT.md

# Prior plan output needed: Drizzle client, env config
@.planning/phases/01-project-foundation-database-deployment/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Drizzle schema for recipes, ingredients, and tags</name>
  <files>
    src/db/schema/common.ts
    src/db/schema/recipes.ts
    src/db/schema/ingredients.ts
    src/db/schema/tags.ts
    src/db/schema/index.ts
    src/db/index.ts
  </files>
  <action>
    1. Create `src/db/schema/common.ts` with reusable columns:
    - `idColumn`: uuid().primaryKey().defaultRandom()
    - `timestamps`: createdAt (timestamp with timezone, defaultNow, notNull), updatedAt (timestamp with timezone, defaultNow, notNull, $onUpdateFn(() => new Date())), deletedAt (timestamp with timezone, nullable)
    - Use precision: 3 and withTimezone: true on all timestamps
    (See exact pattern in RESEARCH.md "Pattern 1")

    2. Create `src/db/schema/recipes.ts`:
    - Table name: "recipes"
    - Spread ...idColumn and ...timestamps
    - Columns: jowId (text, unique, notNull), title (text, notNull), imageUrl (text, nullable), jowUrl (text, notNull), cookTimeMin (integer, nullable), originalPortions (integer, nullable)
    - Use camelCase in TypeScript -- Drizzle casing option handles snake_case conversion
    - Export the table and its relations

    3. Create `src/db/schema/ingredients.ts` with TWO tables:
    - `ingredients` table: ...idColumn, ...timestamps, name (text, notNull), caloriesPer100g (real, nullable), proteinPer100g (real, nullable), carbsPer100g (real, nullable), fatPer100g (real, nullable)
    - `recipeIngredients` junction table: ...idColumn, ...timestamps, recipeId (uuid, notNull, references recipes.id), ingredientId (uuid, notNull, references ingredients.id), quantity (real, nullable), unit (text, nullable), originalText (text -- raw ingredient text from source)
    - Add a unique constraint on recipeIngredients(recipeId, ingredientId) to prevent duplicates
    - Define relations: recipe has many recipeIngredients, ingredient has many recipeIngredients

    4. Create `src/db/schema/tags.ts` with TWO tables:
    - `tags` table: ...idColumn, ...timestamps, name (text, unique, notNull), slug (text, unique, notNull)
    - `recipeTags` junction table: ...idColumn, ...timestamps, recipeId (uuid, notNull, references recipes.id), tagId (uuid, notNull, references tags.id)
    - Add a unique constraint on recipeTags(recipeId, tagId)
    - Define relations: recipe has many recipeTags, tag has many recipeTags

    5. Create `src/db/schema/index.ts` -- barrel export:
    - Export everything from ./common, ./recipes, ./ingredients, ./tags

    6. Update `src/db/index.ts` to import and bind schema:
    - Add `import * as schema from "./schema"`
    - Add `schema` parameter to drizzle() call: `drizzle(client, { schema, casing: "snake_case" })`

    IMPORTANT: Use camelCase for all TypeScript column names. The `casing: "snake_case"` config handles conversion. Do NOT manually specify column names like `text("jow_id")` -- just use `jowId: text()`.

    IMPORTANT: Use `real()` (not `doublePrecision()`) for macro nutrient values -- sufficient precision for nutritional data.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes (no type errors in schema files)
    - All schema files exist and export their tables
    - `src/db/schema/index.ts` re-exports all tables
  </verify>
  <done>All 5 schema files created (common, recipes, ingredients, tags, index). Tables use UUID ids, soft delete, timestamps. Junction tables have unique constraints and foreign keys. Drizzle client bound to schema.</done>
</task>

<task type="auto">
  <name>Task 2: Generate migrations, apply to dev DB, and create seed script</name>
  <files>
    drizzle/
    src/db/seed.ts
  </files>
  <action>
    1. Ensure Docker Compose dev DB is running: `docker compose up -d db`

    2. Generate migrations: `pnpm db:generate`
    - This creates timestamped SQL migration files in `./drizzle/`
    - Inspect the generated SQL to verify: table names are snake_case, column names are snake_case, UUIDs use gen_random_uuid()
    - If column names appear as camelCase in the SQL, the casing config is wrong -- fix it

    3. Apply migrations: `pnpm db:migrate`
    - This runs the SQL against the dev database
    - Verify tables exist: connect to DB and run `\dt` or query information_schema

    4. Create `src/db/seed.ts` executable seed script:
    - Import the db client and schema tables
    - Import postgres and drizzle directly (don't rely on env.ts -- seed runs standalone via tsx)
    - Use dotenv to load .env
    - Insert 3-5 sample recipes with realistic data:
      - "Poulet Grille aux Legumes" (chicken with vegetables)
      - "Pates Bolognaise" (pasta bolognese)
      - "Salade Cesar" (caesar salad)
    - Insert 8-10 sample ingredients with macro data:
      - Poulet (chicken breast): ~165 cal, 31g protein, 0g carbs, 3.6g fat per 100g
      - Pates (pasta): ~131 cal, 5g protein, 25g carbs, 1.1g fat per 100g
      - Tomate (tomato): ~18 cal, 0.9g protein, 3.9g carbs, 0.2g fat per 100g
      - Laitue (lettuce): ~15 cal, 1.4g protein, 2.9g carbs, 0.2g fat per 100g
      - Parmesan: ~431 cal, 38g protein, 4.1g carbs, 29g fat per 100g
    - Link ingredients to recipes via recipeIngredients with realistic quantities
    - Insert 3-4 tags: "volaille" (poultry), "rapide" (quick), "salade" (salad), "pates" (pasta)
    - Link tags to recipes via recipeTags
    - Use upsert pattern (onConflictDoNothing) so seed is idempotent
    - Script should be runnable via `pnpm db:seed` (using tsx)

    5. Run the seed: `pnpm db:seed`
    - Verify data: query recipes table and confirm 3+ rows
    - Verify joins: query recipeIngredients with join to confirm relationships

    IMPORTANT: The seed script should use `import "dotenv/config"` at the top to load env vars. Create a standalone postgres + drizzle connection (do NOT import from src/db/index.ts which uses @t3-oss/env-nextjs -- that requires Next.js runtime).
  </action>
  <verify>
    - `ls drizzle/*.sql` shows at least one migration file
    - Migration SQL has snake_case table and column names (not camelCase)
    - `pnpm db:seed` runs without errors
    - `docker compose exec db psql -U mealprep -d mealprep -c "SELECT count(*) FROM recipes"` returns 3+
    - `docker compose exec db psql -U mealprep -d mealprep -c "SELECT r.title, i.name FROM recipes r JOIN recipe_ingredients ri ON r.id = ri.recipe_id JOIN ingredients i ON i.id = ri.ingredient_id LIMIT 5"` returns joined data
  </verify>
  <done>Versioned SQL migrations generated and applied to dev Postgres. Seed script populates 3+ recipes, 8+ ingredients with macros, junction table relationships, and 3+ tags. Seed is idempotent (safe to re-run).</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with all schema files
2. `drizzle/` contains versioned SQL migration files with snake_case naming
3. Dev Postgres has all tables: recipes, ingredients, recipe_ingredients, tags, recipe_tags
4. Seed data is queryable with joins working correctly
5. All tables have id (UUID), created_at, updated_at, deleted_at columns
6. Junction tables have unique constraints preventing duplicates
</verification>

<success_criteria>
- 5 schema files exist with correct table definitions
- Migrations generated and applied to dev database
- Seed script populates realistic sample data
- Foreign keys and junction tables work correctly
- Schema uses camelCase in TS, snake_case in DB (verified via migration SQL)
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation-database-deployment/01-02-SUMMARY.md`
</output>
