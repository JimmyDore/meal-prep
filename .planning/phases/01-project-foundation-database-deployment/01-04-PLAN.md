---
phase: 01-project-foundation-database-deployment
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/sources/types.ts
  - src/sources/jow.ts
  - src/sources/__tests__/jow.test.ts
autonomous: true

must_haves:
  truths:
    - "RecipeSource interface defines the contract for all recipe data sources"
    - "JowRecipeSource implements RecipeSource with stub methods"
    - "A test verifies JowRecipeSource conforms to the interface"
  artifacts:
    - path: "src/sources/types.ts"
      provides: "RecipeSource interface, RawRecipe type, RawIngredient type"
      exports: ["RecipeSource", "RawRecipe", "RawIngredient"]
    - path: "src/sources/jow.ts"
      provides: "JowRecipeSource class implementing RecipeSource"
      exports: ["JowRecipeSource"]
    - path: "src/sources/__tests__/jow.test.ts"
      provides: "Tests for JowRecipeSource stub"
      contains: "JowRecipeSource"
  key_links:
    - from: "src/sources/jow.ts"
      to: "src/sources/types.ts"
      via: "implements RecipeSource"
      pattern: "implements RecipeSource"
---

<objective>
Implement the adapter pattern for recipe data sources: a RecipeSource interface and the JowRecipeSource stub implementation.

Purpose: This abstraction decouples the application from Jow as the sole recipe source. Future sources (other websites, manual entry, API) implement the same interface. The pattern is a Phase 1 requirement from the roadmap.
Output: RecipeSource interface, RawRecipe/RawIngredient types, JowRecipeSource stub, and tests.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation-database-deployment/01-RESEARCH.md
@.planning/phases/01-project-foundation-database-deployment/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RecipeSource interface and JowRecipeSource stub</name>
  <files>
    src/sources/types.ts
    src/sources/jow.ts
  </files>
  <action>
    1. Create `src/sources/types.ts` with the adapter pattern types:

    ```typescript
    export interface RawIngredient {
      name: string;
      quantity?: number;
      unit?: string;
    }

    export interface RawRecipe {
      sourceId: string;         // Unique ID from the source (e.g., Jow recipe slug)
      sourceName: string;       // "jow", "marmiton", etc.
      sourceUrl: string;        // Original URL on source site
      title: string;
      imageUrl?: string;
      cookTimeMin?: number;
      originalPortions?: number;
      ingredients: RawIngredient[];
    }

    export interface RecipeSource {
      readonly name: string;
      fetchRecipes(): Promise<RawRecipe[]>;
      fetchRecipeById(id: string): Promise<RawRecipe | null>;
    }
    ```

    2. Create `src/sources/jow.ts` implementing the interface:

    ```typescript
    import type { RecipeSource, RawRecipe } from "./types";

    export class JowRecipeSource implements RecipeSource {
      readonly name = "jow";

      async fetchRecipes(): Promise<RawRecipe[]> {
        // Phase 2: Playwright scraping implementation
        throw new Error("Not implemented - see Phase 2");
      }

      async fetchRecipeById(id: string): Promise<RawRecipe | null> {
        // Phase 2: Playwright scraping implementation
        throw new Error("Not implemented - see Phase 2");
      }
    }
    ```

    The interface is intentionally minimal. Phase 2 adds the real Playwright scraping logic. The stub proves the architecture compiles and the contract is established.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes with no type errors
    - `src/sources/types.ts` exports RecipeSource, RawRecipe, RawIngredient
    - `src/sources/jow.ts` exports JowRecipeSource
  </verify>
  <done>RecipeSource interface and RawRecipe/RawIngredient types defined. JowRecipeSource stub implements the interface with throw stubs for Phase 2.</done>
</task>

<task type="auto">
  <name>Task 2: Write tests for the adapter pattern</name>
  <files>
    src/sources/__tests__/jow.test.ts
  </files>
  <action>
    1. Create `src/sources/__tests__/jow.test.ts`:

    - Test that JowRecipeSource can be instantiated
    - Test that it has name = "jow"
    - Test that fetchRecipes() throws "Not implemented" (expected behavior for stub)
    - Test that fetchRecipeById() throws "Not implemented"
    - Test that JowRecipeSource satisfies the RecipeSource interface at the type level:
      ```typescript
      it("should satisfy RecipeSource interface", () => {
        const source: RecipeSource = new JowRecipeSource();
        expect(source.name).toBe("jow");
        expect(typeof source.fetchRecipes).toBe("function");
        expect(typeof source.fetchRecipeById).toBe("function");
      });
      ```

    2. Run `pnpm test run src/sources` and verify all tests pass.
  </action>
  <verify>
    - `pnpm test run src/sources` passes with 4+ tests
    - All tests verify the adapter contract
  </verify>
  <done>JowRecipeSource tested: instantiation, name property, interface conformance, and stub behavior (throws "Not implemented"). Adapter pattern architecture validated.</done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` passes with adapter pattern files
2. `pnpm test run src/sources` passes all adapter tests
3. RecipeSource interface is a clean abstraction (no Jow-specific details)
4. JowRecipeSource implements RecipeSource correctly
</verification>

<success_criteria>
- RecipeSource interface defines fetchRecipes() and fetchRecipeById() contract
- RawRecipe and RawIngredient types capture source-agnostic recipe data
- JowRecipeSource is a stub ready for Phase 2 implementation
- Tests prove the interface contract and stub behavior
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation-database-deployment/01-04-SUMMARY.md`
</output>
