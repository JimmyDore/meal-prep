---
phase: 01-project-foundation-database-deployment
plan: 06
type: execute
wave: 3
depends_on: ["01-02", "01-03", "01-05"]
files_modified:
  - .github/workflows/deploy.yml
  - src/app/page.tsx
  - src/app/layout.tsx
autonomous: false

must_haves:
  truths:
    - "Push to main triggers GitHub Actions workflow"
    - "CI pipeline runs lint, type-check, and tests before deploy"
    - "Successful CI triggers SSH deploy to VPS"
    - "Hello World page in production connects to Postgres and displays server time"
    - "App is accessible via HTTPS at the configured domain"
  artifacts:
    - path: ".github/workflows/deploy.yml"
      provides: "CI/CD pipeline: lint, type-check, test, deploy"
      contains: "appleboy/ssh-action"
    - path: "src/app/page.tsx"
      provides: "Hello World page with DB connection proof"
      contains: "SELECT NOW()"
  key_links:
    - from: ".github/workflows/deploy.yml"
      to: "VPS"
      via: "SSH deploy with appleboy/ssh-action"
      pattern: "ssh-action"
    - from: "src/app/page.tsx"
      to: "src/db/index.ts"
      via: "Drizzle client import"
      pattern: "import.*db"
    - from: ".github/workflows/deploy.yml"
      to: "docker-compose.prod.yml"
      via: "docker compose build and up"
      pattern: "docker compose.*prod"
---

<objective>
Create the GitHub Actions CI/CD pipeline and Hello World frontend that proves the full stack works end-to-end in production: push to main triggers lint/test/deploy, and the deployed page connects to Postgres.

Purpose: This is the capstone of Phase 1 -- proving the entire stack works from code push to production database query. Every subsequent phase ships through this pipeline.
Output: GitHub Actions workflow, Hello World page with DB connection, verified production deployment.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-project-foundation-database-deployment/01-RESEARCH.md
@.planning/phases/01-project-foundation-database-deployment/01-CONTEXT.md

# Need schema for DB query, test config for CI, VPS details from user
@.planning/phases/01-project-foundation-database-deployment/01-02-SUMMARY.md
@.planning/phases/01-project-foundation-database-deployment/01-03-SUMMARY.md
@.planning/phases/01-project-foundation-database-deployment/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions CI/CD workflow</name>
  <files>
    .github/workflows/deploy.yml
  </files>
  <action>
    1. Create `.github/workflows/deploy.yml`:

    ```yaml
    name: Deploy

    on:
      push:
        branches: [main]

    jobs:
      build-and-deploy:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v4

          - uses: pnpm/action-setup@v4
            with:
              version: 10

          - uses: actions/setup-node@v4
            with:
              node-version: 22
              cache: "pnpm"

          - run: pnpm install --frozen-lockfile

          - name: Lint & format check
            run: pnpm biome ci .

          - name: Type check
            run: pnpm tsc --noEmit

          - name: Run tests
            run: pnpm test run
            env:
              DATABASE_URL: "postgresql://skip:skip@localhost:5432/skip"
              NODE_ENV: test

          - name: Deploy to VPS
            uses: appleboy/ssh-action@v1.2.4
            with:
              host: ${{ secrets.VPS_HOST }}
              username: ${{ secrets.VPS_USER }}
              key: ${{ secrets.VPS_SSH_KEY }}
              script: |
                cd /opt/mealprep
                git pull origin main
                docker compose -f docker-compose.prod.yml build
                docker compose -f docker-compose.prod.yml up -d
                docker image prune -f
    ```

    Key decisions:
    - CI runs lint, type-check, and unit tests (integration tests that need DB are skipped in CI for now -- the test command should handle this gracefully via test configuration or by only running non-DB tests in CI)
    - DATABASE_URL in CI is a dummy value -- the env validation in t3-oss/env-nextjs needs a valid-looking URL even if not connected. Set NODE_ENV=test to skip actual DB connections during type-check.
    - Deploy step: SSH into VPS, pull latest, rebuild Docker images, restart containers, prune old images
    - Uses GitHub Secrets: VPS_HOST, VPS_USER, VPS_SSH_KEY (set by user in Plan 05)

    2. Handle the env validation issue in CI: The `@t3-oss/env-nextjs` validation will fail during `tsc --noEmit` if DATABASE_URL is not set. Options:
    - Set a dummy DATABASE_URL env var in CI (recommended -- already done above)
    - Or add `skipValidation: !!process.env.CI` to the env config in src/lib/env.ts

    Add `skipValidation: !!process.env.SKIP_ENV_VALIDATION` to the env.ts createEnv call so CI can skip validation when needed. Set `SKIP_ENV_VALIDATION=1` in the CI test step if integration tests are excluded.

    3. For the test step in CI: configure Vitest to exclude integration tests when running in CI. Add a vitest workspace config or use a test file naming convention:
    - Unit tests: `*.test.ts`
    - Integration tests: `*.integration.test.ts` or in `__tests__/db/` folder
    - CI runs: `pnpm test run --exclude '**/db/**'` or similar

    The simplest approach: update the test run step to exclude db tests: `pnpm test run --exclude 'src/db/**'`

    4. Add a migration step to the deploy script (in the SSH action script), so migrations run on each deploy:
    ```
    docker compose -f docker-compose.prod.yml exec app node -e "require('./node_modules/drizzle-orm/postgres-js/migrator').migrate(require('./src/db').db, {migrationsFolder: './drizzle'})"
    ```
    OR simpler: add a `db:migrate` step in the deploy that runs inside the app container after it starts. The cleanest approach is to have the app run migrations on startup via a custom entrypoint, or add it to the deploy script:
    ```
    docker compose -f docker-compose.prod.yml exec -T app npx drizzle-kit migrate
    ```
    NOTE: In standalone mode, drizzle-kit might not be available. Instead, use a migration script that imports drizzle-orm migrator. Add a `migrate.mjs` script at project root that runs migrations, and execute it via Docker:
    ```
    docker compose -f docker-compose.prod.yml run --rm app node migrate.mjs
    ```

    Simplest reliable approach: add migrations to the Docker entrypoint. Create a small `scripts/migrate-and-start.sh`:
    ```bash
    #!/bin/sh
    node migrate.js
    node server.js
    ```
    And a `migrate.js` that uses the drizzle migrator. Update Dockerfile CMD to use this script.

    Choose the approach that works cleanest with the standalone build. Document the decision.
  </action>
  <verify>
    - `.github/workflows/deploy.yml` exists with proper YAML syntax
    - `act -j build-and-deploy --dryrun` (if act installed) shows valid workflow, OR manual YAML validation
    - Workflow has steps: checkout, pnpm setup, node setup, install, lint, type-check, test, deploy
    - Deploy step uses secrets for VPS connection
  </verify>
  <done>GitHub Actions CI/CD workflow created. Pipeline: checkout -> pnpm install -> biome lint -> tsc type-check -> vitest tests -> SSH deploy to VPS. Migrations run on deploy before app starts.</done>
</task>

<task type="auto">
  <name>Task 2: Create Hello World frontend with DB connection proof</name>
  <files>
    src/app/page.tsx
    src/app/layout.tsx
  </files>
  <action>
    1. Update `src/app/page.tsx` to be the Hello World page:
    - This is a React Server Component (no "use client" directive)
    - Import db from "@/db"
    - Import sql from "drizzle-orm"
    - Query the database: `const result = await db.execute(sql\`SELECT NOW() as current_time\`)`
    - Also query recipe count: `const recipeCount = await db.execute(sql\`SELECT count(*) as count FROM recipes\`)`
    - Display:
      - "Meal Prep" heading (h1, text-4xl font-bold)
      - "Database connected successfully" subtitle (green text or success indicator)
      - "Server time: {timestamp}" from SELECT NOW()
      - "Recipes in database: {count}" from recipe count
      - Use Tailwind classes for centering and styling (flex, min-h-screen, items-center, justify-center, flex-col, gap-4)
    - Wrap DB queries in try/catch. If connection fails, show error message in red instead.
    (See code example in RESEARCH.md "Hello World Server Component with DB Query")

    2. Ensure `src/app/layout.tsx` has proper metadata:
    - title: "Meal Prep"
    - description: "Macro-optimized meal planning"
    - Keep the default shadcn/ui setup (font, theme provider if initialized)

    3. Verify locally: `pnpm dev` and visit http://localhost:3000
    - Should show "Meal Prep" heading, DB connection status, server time, recipe count
    - If seed data was run (Plan 02), recipe count should be 3+

    4. Build test: `pnpm build` should succeed (this validates the standalone output for Docker)
  </action>
  <verify>
    - `pnpm dev` shows Hello World page at http://localhost:3000 with DB data
    - `pnpm build` succeeds without errors
    - Page displays server time from Postgres (not just static text)
    - Page displays recipe count (proves schema + seed are working)
  </verify>
  <done>Hello World page displays DB connection status, server time from SELECT NOW(), and recipe count. Build succeeds in standalone mode ready for Docker production deployment.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete CI/CD pipeline and Hello World frontend. When pushed to main, GitHub Actions will lint, test, and deploy to VPS. The Hello World page in production queries the Postgres database and displays the result.</what-built>
  <how-to-verify>
    1. Push all Phase 1 code to the main branch
    2. Watch GitHub Actions run at https://github.com/YOUR_REPO/actions
    3. Verify all CI steps pass (lint, type-check, test, deploy)
    4. Visit https://your-domain in a browser
    5. Confirm you see:
       - "Meal Prep" heading
       - "Database connected successfully" (or similar)
       - Server time from Postgres
       - Recipe count (should be 3+ if seed ran)
    6. Verify HTTPS with valid SSL certificate (padlock icon in browser)
  </how-to-verify>
  <resume-signal>Type "production verified" if the app is live and showing DB data, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. GitHub Actions workflow triggers on push to main
2. CI passes: lint, type-check, test
3. Deploy step SSHs to VPS and restarts Docker containers
4. Hello World page accessible at https://domain with valid SSL
5. Page shows live data from Postgres (server time, recipe count)
6. Full stack proven: code push -> CI -> deploy -> DB query -> browser
</verification>

<success_criteria>
- GitHub Actions CI/CD pipeline functional (lint + type-check + test + deploy)
- Hello World frontend connects to production Postgres
- App accessible via HTTPS with valid SSL certificate
- Automatic deployment on push to main works end-to-end
- All 7 Phase 1 success criteria from ROADMAP.md are met
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-foundation-database-deployment/01-06-SUMMARY.md`
</output>
