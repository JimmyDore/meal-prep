---
phase: 03-recipe-catalogue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - next.config.ts
  - src/db/queries/recipes.ts
  - src/db/queries/tags.ts
  - src/components/recipe-card.tsx
  - src/components/macro-badge.tsx
  - src/components/ui/*.tsx (shadcn auto-generated)
autonomous: true

must_haves:
  truths:
    - "getRecipes returns paginated recipes with totalCount and totalPages"
    - "getRecipes filters by title ilike with escaped special characters"
    - "getRecipes filters by tag slugs using AND logic (all tags must match)"
    - "getRecipes returns recipes with tags nested on each recipe object"
    - "getRecipeById returns recipe with nested ingredients and tags"
    - "getAllTags returns all tags sorted by name"
    - "Next.js Image can load images from static.jow.fr and img.jow.fr"
  artifacts:
    - path: "src/db/queries/recipes.ts"
      provides: "getRecipes (paginated list with search+filter, tags nested per recipe) and getRecipeById (detail with relations)"
      exports: ["getRecipes", "getRecipeById"]
    - path: "src/db/queries/tags.ts"
      provides: "getAllTags query"
      exports: ["getAllTags"]
    - path: "src/components/recipe-card.tsx"
      provides: "RecipeCard component displaying image, title, time, difficulty, tags"
      exports: ["RecipeCard"]
    - path: "src/components/macro-badge.tsx"
      provides: "MacroBadge component for displaying P/C/F values"
      exports: ["MacroBadge"]
    - path: "next.config.ts"
      provides: "Image remotePatterns for static.jow.fr and img.jow.fr"
      contains: "remotePatterns"
  key_links:
    - from: "src/db/queries/recipes.ts"
      to: "src/db/schema"
      via: "drizzle query builder"
      pattern: "from\\(recipes\\)|db\\.query\\.recipes"
    - from: "src/components/recipe-card.tsx"
      to: "next/image"
      via: "Next.js Image component"
      pattern: "import Image from"
    - from: "src/components/recipe-card.tsx"
      to: "getRecipes return type"
      via: "recipe.tags property access"
      pattern: "recipe\\.tags"
---

<objective>
Install shadcn/ui components, configure Next.js image domains, create reusable DB query functions for recipes and tags, and build shared UI components (RecipeCard, MacroBadge).

Purpose: Establishes the shared foundation (queries + components) that both the catalogue page and detail page depend on. Without this, neither page can render data or display recipe cards.
Output: Query layer in src/db/queries/, reusable components in src/components/, next.config.ts with image domains, shadcn/ui components installed.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-recipe-catalogue/03-RESEARCH.md
@src/db/schema/recipes.ts
@src/db/schema/tags.ts
@src/db/schema/ingredients.ts
@src/db/index.ts
@next.config.ts
@components.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install shadcn/ui components + configure Next.js image domains</name>
  <files>
    next.config.ts
    src/components/ui/*.tsx (auto-generated by shadcn CLI)
  </files>
  <action>
    1. Install shadcn/ui components in a single command:
       `pnpm dlx shadcn@latest add card badge input button pagination skeleton separator`
       This creates files in src/components/ui/ and may update globals.css with CSS variables.

    2. Update next.config.ts to add image remotePatterns for Jow recipe images:
       ```typescript
       import type { NextConfig } from "next";

       const nextConfig: NextConfig = {
         output: "standalone",
         images: {
           remotePatterns: [
             { protocol: "https", hostname: "static.jow.fr" },
             { protocol: "https", hostname: "img.jow.fr" },
           ],
         },
       };

       export default nextConfig;
       ```

    3. Verify the shadcn components were installed by checking that src/components/ui/card.tsx, src/components/ui/badge.tsx, etc. exist.
  </action>
  <verify>
    - `ls src/components/ui/` shows card.tsx, badge.tsx, input.tsx, button.tsx, pagination.tsx, skeleton.tsx, separator.tsx
    - `pnpm tsc --noEmit` passes (no type errors from new components)
    - next.config.ts contains remotePatterns with static.jow.fr
  </verify>
  <done>
    All 7 shadcn/ui components installed in src/components/ui/, next.config.ts has image remotePatterns for static.jow.fr and img.jow.fr, project compiles without type errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DB query functions and shared UI components</name>
  <files>
    src/db/queries/recipes.ts
    src/db/queries/tags.ts
    src/components/recipe-card.tsx
    src/components/macro-badge.tsx
  </files>
  <action>
    1. Create src/db/queries/recipes.ts with two exported functions:

       **getRecipes({ page, query, tagSlugs, pageSize }):**
       - Default pageSize = 12, page = 1
       - Build WHERE conditions dynamically:
         - If query non-empty: `ilike(recipes.title, '%${escapeIlike(query.trim())}%')` (escape %, _, \ characters)
         - For each tagSlug: `exists()` subquery on recipeTags joined to tags where tags.slug matches (AND logic -- recipe must have ALL tags)
       - Run two parallel queries: (a) paginated select with orderBy(asc(recipes.title)), limit(pageSize), offset((page-1)*pageSize), (b) count query with same WHERE
       - IMPORTANT: Tags must be nested on each recipe object. After getting the paginated recipe rows, fetch tags for those recipe IDs in a single batch query: join recipeTags + tags WHERE recipeId IN (...ids). Then merge tags onto each recipe in application code, producing objects shaped as `{ ...recipeFields, tags: Array<{ id, name, slug }> }`.
         Alternative approach: Use db.query.recipes.findMany with `with: { recipeTags: { with: { tag: true } } }` and manually apply where/limit/offset. Pick whichever approach works cleaner with Drizzle 0.45.
       - Return type: `{ recipes: RecipeWithTags[], totalCount, totalPages, currentPage, pageSize }` where `RecipeWithTags` is a recipe row with an added `tags: Array<{ id: string; name: string; slug: string }>` property
       - Export the `RecipeWithTags` type so downstream components can import it

       **getRecipeById(id: string):**
       - Use db.query.recipes.findFirst with `where: eq(recipes.id, id)` and `with: { recipeIngredients: { with: { ingredient: true } }, recipeTags: { with: { tag: true } } }`
       - Returns full recipe with nested ingredients (including their macros) and tags, or undefined if not found

       Helper: `escapeIlike(input: string): string` -- replaces %, _, \ with escaped versions

    2. Create src/db/queries/tags.ts:

       **getAllTags():**
       - `db.select().from(tags).orderBy(asc(tags.name))`
       - Returns all tags sorted alphabetically by name

    3. Create src/components/macro-badge.tsx:

       A small server-compatible component that displays a macro value with label and color.
       Props: `{ label: string; value: number; unit?: string; color: "red" | "blue" | "yellow" | "green" }`
       Renders: colored badge-like span showing e.g. "P 32g" for protein.
       Use Tailwind classes for colors (bg-red-100 text-red-700 etc for protein, blue for carbs, yellow for fat, green for calories).
       Keep it simple -- a small rounded pill.

    4. Create src/components/recipe-card.tsx:

       Props: `{ recipe: RecipeWithTags }` -- a single object containing the recipe fields AND a nested `tags` array. Import RecipeWithTags type from src/db/queries/recipes.
       Uses shadcn Card component. Layout:
       - Next.js Image (304x304 aspect-square, object-cover) with recipe.imageUrl, fallback to a placeholder div with gray background if no imageUrl
       - CardHeader: recipe.title (font-semibold, line-clamp-2)
       - CardContent: totalTimeMin displayed as "X min" if available, difficulty badge, tag badges from `recipe.tags` (max 3 shown, using shadcn Badge variant="secondary")
       - The entire card is wrapped in a Next.js Link to `/recipes/${recipe.id}`
       - Hover effect: subtle shadow lift (hover:shadow-lg transition-shadow)

       Do NOT use "use client" -- this is a server component. The Link wrapping handles navigation.
  </action>
  <verify>
    - `pnpm tsc --noEmit` passes
    - `pnpm check` (Biome) passes with no errors
    - src/db/queries/recipes.ts exports getRecipes, getRecipeById, and RecipeWithTags type
    - src/db/queries/tags.ts exports getAllTags
    - src/components/recipe-card.tsx exports RecipeCard and accepts { recipe: RecipeWithTags }
    - src/components/macro-badge.tsx exports MacroBadge
  </verify>
  <done>
    Query functions (getRecipes with pagination/search/filter returning RecipeWithTags[], getRecipeById with relations, getAllTags) are working and type-safe. RecipeCard accepts a single RecipeWithTags object and renders image, title, time, difficulty, and recipe.tags. MacroBadge renders colored macro pills. All code passes type-check and lint.
  </done>
</task>

</tasks>

<verification>
1. `pnpm tsc --noEmit` -- no type errors across entire project
2. `pnpm check` -- Biome lint/format passes
3. `ls src/components/ui/` shows 7 shadcn components
4. `ls src/db/queries/` shows recipes.ts and tags.ts
5. `ls src/components/` shows recipe-card.tsx and macro-badge.tsx
6. next.config.ts includes remotePatterns with both jow hostnames
</verification>

<success_criteria>
- 7 shadcn/ui components installed and importable
- next.config.ts allows images from static.jow.fr and img.jow.fr
- getRecipes returns paginated results with tags nested on each recipe (RecipeWithTags[])
- getRecipeById returns recipe with nested ingredients + tags
- getAllTags returns all tags sorted by name
- RecipeCard accepts { recipe: RecipeWithTags } and renders image, title, time, difficulty, tags
- MacroBadge renders colored macro value pills
- All code compiles and passes lint
</success_criteria>

<output>
After completion, create `.planning/phases/03-recipe-catalogue/03-01-SUMMARY.md`
</output>
