# Phase 4.1: Comprehensive Unit Tests - Research

**Researched:** 2026-02-08
**Domain:** Unit testing for Next.js 16 + Vitest + React Testing Library codebase
**Confidence:** HIGH

## Summary

This phase covers comprehensive unit tests for the existing codebase (Phases 1-4): data pipeline pure/impure functions, API upload route, DB integration queries, Zod schemas (pipeline + profile), and interactive React components. The project already has Vitest 4.0.18 configured with jsdom, @testing-library/react 16.3.2, and @testing-library/jest-dom 6.9.1. A test DB setup utility (`src/test/db-setup.ts`) already handles schema push and cleanup via drizzle-kit.

The existing test suite is minimal: 3 test files totaling ~15 assertions -- 1 smoke test for the JowRecipeSource adapter, 1 env test, and 1 DB connection integration test. Zero pipeline functions, zero Zod schemas, zero React components, and zero API routes are currently tested.

**Primary recommendation:** Write tests in 6 categories following the project's existing conventions: (1) pipeline pure functions, (2) pipeline impure functions with mocks, (3) Zod schemas at boundaries, (4) API upload route with mocked DB and env, (5) DB integration tests with test DB, (6) React components with mocked next/navigation and authClient. The vitest config must be updated to include `scripts/**/*.test.ts` for pipeline tests.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| vitest | 4.0.18 | Test runner + assertions | Already installed and configured |
| @testing-library/react | 16.3.2 | React component testing | Already installed |
| @testing-library/jest-dom | 6.9.1 | DOM matchers (toBeInTheDocument, etc.) | Already installed, loaded in setup.ts |
| @testing-library/dom | 10.4.1 | Core DOM testing utilities | Already installed |
| jsdom | 28.0.0 | Browser environment for tests | Already configured in vitest.config.mts |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @vitejs/plugin-react | 5.1.3 | JSX transform in tests | Already configured in vitest.config.mts |
| vite-tsconfig-paths | 6.1.0 | Path alias (@/*) resolution in tests | Already configured |
| zod | 3.25.76 | Schema validation testing | Already installed, schemas to test |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| vi.mock() for fetch | msw (Mock Service Worker) | msw is more realistic but overkill -- vi.mock()/globalThis.fetch override is simpler for this codebase's API testing needs |
| @testing-library/user-event | direct fireEvent | user-event is more realistic for input simulation, but the components use onChange handlers, and the existing setup does not include user-event. fireEvent suffices. |

**Installation:** No new packages needed. All testing dependencies are already installed.

## Architecture Patterns

### Recommended Test File Structure
```
src/
  lib/
    __tests__/
      env.test.ts                # EXISTING (minimal)
    schemas/
      __tests__/
        profile.test.ts          # NEW: profile Zod schemas boundary tests
  db/
    __tests__/
      connection.test.ts         # EXISTING (DB integration)
      recipes.test.ts            # NEW: recipe queries integration tests
      profiles.test.ts           # NEW: profile queries integration tests
  sources/
    __tests__/
      jow.test.ts               # EXISTING (minimal smoke)
  components/
    __tests__/
      search-bar.test.tsx        # NEW
      tag-filter.test.tsx        # NEW
      pagination-controls.test.tsx # NEW
    auth/
      __tests__/
        login-form.test.tsx      # NEW
        register-form.test.tsx   # NEW
    onboarding/
      __tests__/
        wizard.test.tsx          # NEW
  app/
    api/
      recipes/
        upload/
          __tests__/
            route.test.ts        # NEW: API upload tests
scripts/
  pipeline/
    lib/
      __tests__/
        jow-parser.test.ts      # NEW: pure parser functions
        schemas.test.ts          # NEW: pipeline Zod schemas
        claude-enricher.test.ts  # NEW: enricher with mocked execSync
        recipe-assembler.test.ts # NEW: assembler pure logic
        jsonl.test.ts            # NEW: JSONL utils with mocked fs
        api-client.test.ts       # NEW: API client with mocked fetch
        ingredient-extractor.test.ts # NEW: extractor with mocked JSONL
```

### Pattern 1: Pure Function Testing (Pipeline)
**What:** Test pure functions directly with boundary values, edge cases, and expected outputs.
**When to use:** For `jow-parser.ts` functions (extractJowId, extractRecipeSlug, parseIsoDuration, parseNextDataRecipe, parseJsonLdRecipe), `recipe-assembler.ts` (assembleEnrichedRecipe), and `claude-enricher.ts` pure helpers (parseClaudeOutput, validateIngredients, boundsCheck, crossValidateNutrition).
**Example:**
```typescript
// scripts/pipeline/lib/__tests__/jow-parser.test.ts
import { describe, expect, it } from "vitest";
import { extractJowId, parseIsoDuration } from "../jow-parser";

describe("extractJowId", () => {
  it("extracts ID after last dash", () => {
    expect(extractJowId("https://jow.fr/recipes/poulet-au-curry-89y06dxjhfua0twu16x5"))
      .toBe("89y06dxjhfua0twu16x5");
  });

  it("returns full segment if no dash", () => {
    expect(extractJowId("https://jow.fr/recipes/nodash")).toBe("nodash");
  });
});

describe("parseIsoDuration", () => {
  it("parses PT30M", () => expect(parseIsoDuration("PT30M")).toBe(30));
  it("parses PT1H15M", () => expect(parseIsoDuration("PT1H15M")).toBe(75));
  it("returns null for empty string", () => expect(parseIsoDuration("")).toBeNull());
  it("returns null for invalid format", () => expect(parseIsoDuration("30min")).toBeNull());
});
```

### Pattern 2: Impure Function Testing with Mocks (Pipeline)
**What:** Test functions that interact with filesystem, network, or child_process by mocking those dependencies.
**When to use:** For `jsonl.ts` (mock fs streams), `api-client.ts` (mock fetch), `claude-enricher.ts` (mock execSync, fs operations), `ingredient-extractor.ts` (mock readJsonl).
**Example:**
```typescript
// scripts/pipeline/lib/__tests__/api-client.test.ts
import { describe, expect, it, vi, beforeEach } from "vitest";
import { createApiClient } from "../api-client";

describe("createApiClient", () => {
  beforeEach(() => {
    vi.restoreAllMocks();
  });

  it("sends POST with bearer token and returns id on 201", async () => {
    globalThis.fetch = vi.fn().mockResolvedValue({
      status: 201,
      json: () => Promise.resolve({ id: "uuid-123" }),
    });

    const client = createApiClient("http://localhost:3000", "test-token");
    const result = await client.uploadRecipe(/* minimal enriched recipe */);
    expect(result).toEqual({ id: "uuid-123" });
  });

  it("returns error on non-201 response", async () => {
    globalThis.fetch = vi.fn().mockResolvedValue({
      status: 400,
      json: () => Promise.resolve({ error: "Validation failed" }),
    });

    const client = createApiClient("http://localhost:3000", "test-token");
    const result = await client.uploadRecipe(/* minimal enriched recipe */);
    expect("error" in result).toBe(true);
  });
});
```

### Pattern 3: Zod Schema Boundary Testing
**What:** Test Zod schemas at boundaries: min/max values, invalid types, empty arrays, null handling.
**When to use:** For pipeline schemas (`scrapedRecipeSchema`, `enrichedIngredientSchema`, `ingredientMacroSchema`, `enrichedRecipeSchema`) and profile schemas (`physicalSchema`, `goalSchema`, `dietarySchema`, `sportSchema`, `profileSchema`).
**Example:**
```typescript
// scripts/pipeline/lib/__tests__/schemas.test.ts
import { describe, expect, it } from "vitest";
import { enrichedIngredientSchema } from "../schemas";

describe("enrichedIngredientSchema", () => {
  it("accepts valid ingredient at boundaries", () => {
    const result = enrichedIngredientSchema.safeParse({
      name: "poulet",
      proteinPer100g: 0,
      carbsPer100g: 100,
      fatPer100g: 0,
      caloriesPer100g: 0,
      confidence: "high",
    });
    expect(result.success).toBe(true);
  });

  it("rejects protein > 100", () => {
    const result = enrichedIngredientSchema.safeParse({
      name: "poulet",
      proteinPer100g: 101,
      carbsPer100g: 0,
      fatPer100g: 0,
      caloriesPer100g: 0,
      confidence: "high",
    });
    expect(result.success).toBe(false);
  });

  it("rejects calories > 900", () => {
    const result = enrichedIngredientSchema.safeParse({
      name: "huile",
      proteinPer100g: 0,
      carbsPer100g: 0,
      fatPer100g: 100,
      caloriesPer100g: 901,
      confidence: "low",
    });
    expect(result.success).toBe(false);
  });
});
```

### Pattern 4: Next.js API Route Testing
**What:** Test the POST handler by constructing Request objects and mocking `@/db` and `@/lib/env`.
**When to use:** For the upload route handler.
**Important:** The upload route imports `db` from `@/db` and `env` from `@/lib/env`. Both must be mocked.
**Example:**
```typescript
// src/app/api/recipes/upload/__tests__/route.test.ts
import { describe, expect, it, vi, beforeEach } from "vitest";

vi.mock("@/db", () => ({
  db: { transaction: vi.fn() },
}));

vi.mock("@/lib/env", () => ({
  env: { PIPELINE_TOKEN: "test-token" },
}));

import { POST } from "../route";

describe("POST /api/recipes/upload", () => {
  it("returns 401 without bearer token", async () => {
    const req = new Request("http://localhost/api/recipes/upload", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({}),
    });
    const res = await POST(req);
    expect(res.status).toBe(401);
  });

  it("returns 400 on invalid body", async () => {
    const req = new Request("http://localhost/api/recipes/upload", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer test-token",
      },
      body: JSON.stringify({ title: "" }), // Missing required fields
    });
    const res = await POST(req);
    expect(res.status).toBe(400);
  });
});
```

### Pattern 5: React Component Testing with Router Mocks
**What:** Test interactive components by mocking `next/navigation` hooks (useRouter, usePathname, useSearchParams).
**When to use:** For SearchBar, TagFilter, PaginationControls, LoginForm, RegisterForm, OnboardingWizard.
**Critical detail:** Components using `useSearchParams()` need the mock to return a `URLSearchParams` instance. Components using `authClient` need `@/lib/auth-client` mocked.
**Example:**
```typescript
// src/components/__tests__/search-bar.test.tsx
import { render, screen, fireEvent, act } from "@testing-library/react";
import { describe, expect, it, vi, beforeEach } from "vitest";

const mockPush = vi.fn();
vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: mockPush }),
  usePathname: () => "/recipes",
  useSearchParams: () => new URLSearchParams(""),
}));

import { SearchBar } from "../search-bar";

describe("SearchBar", () => {
  beforeEach(() => {
    vi.useFakeTimers();
    mockPush.mockClear();
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it("renders with default value", () => {
    render(<SearchBar defaultValue="poulet" />);
    expect(screen.getByRole("searchbox")).toHaveValue("poulet");
  });

  it("debounces navigation on input change", async () => {
    render(<SearchBar defaultValue="" />);
    fireEvent.change(screen.getByRole("searchbox"), { target: { value: "curry" } });
    expect(mockPush).not.toHaveBeenCalled();
    act(() => { vi.advanceTimersByTime(300); });
    // startTransition wraps the push
  });
});
```

### Pattern 6: DB Integration Tests
**What:** Test real DB queries against the test database (port 5434) using `testDb` from `src/test/db-setup.ts`.
**When to use:** For `src/db/queries/recipes.ts` (getRecipes, getRecipeById) and `src/db/queries/profiles.ts`.
**CI exclusion:** These tests live in `src/db/__tests__/` and are excluded from CI via `--exclude 'src/db/**'`.
**Example:**
```typescript
// src/db/__tests__/recipes.test.ts
import { describe, it, expect, beforeAll, beforeEach, afterAll } from "vitest";
import { sql } from "drizzle-orm";
import { cleanupTestDb, closeTestDb, setupTestDb, testDb } from "@/test/db-setup";
import { recipes, ingredients, recipeIngredients, tags, recipeTags } from "@/db/schema";

// Must override db module to use testDb
vi.mock("@/db", () => ({ db: testDb }));

import { getRecipes, getRecipeById } from "@/db/queries/recipes";

describe("Recipe queries (integration)", () => {
  beforeAll(() => setupTestDb());
  beforeEach(() => cleanupTestDb());
  afterAll(() => closeTestDb());

  it("returns empty for no recipes", async () => {
    const result = await getRecipes();
    expect(result.recipes).toHaveLength(0);
    expect(result.totalCount).toBe(0);
  });
});
```

### Anti-Patterns to Avoid
- **Testing UI library internals:** Do not test shadcn/ui or Radix primitives themselves. Only test how *your* components use them (user interactions, state changes, navigation).
- **Testing DB from CI:** DB integration tests MUST live in `src/db/__tests__/` so CI can exclude them with `--exclude 'src/db/**'`.
- **Importing `env` directly in test files:** The `@/lib/env` module uses `@t3-oss/env-nextjs` which validates env vars at import time. Always mock `@/lib/env` in tests.
- **Importing `db` directly in test files:** The `@/db` module imports `env` which triggers env validation. Always mock `@/db` or use `testDb` for integration tests.
- **Snapshot testing for React components:** Avoid snapshot tests -- they are brittle and provide low signal. Test behaviors and user interactions instead.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Mocking modules | Custom mock factories | `vi.mock()` with factory functions | Vitest handles hoisting, TypeScript types, and module resolution |
| Timer control for debounce | setTimeout wrappers in tests | `vi.useFakeTimers()` + `vi.advanceTimersByTime()` | Built into Vitest, handles all timer APIs consistently |
| DOM assertions | Custom matchers | `@testing-library/jest-dom` matchers | Already configured in setup.ts, provides toBeInTheDocument, toHaveValue, etc. |
| Test DB lifecycle | Custom SQL scripts | `setupTestDb()` + `cleanupTestDb()` from `src/test/db-setup.ts` | Already built, uses drizzle-kit push for schema sync |
| URLSearchParams mock | Stub objects | `new URLSearchParams("key=value")` | Real URLSearchParams works in jsdom, no stub needed |

**Key insight:** The project already has all the infrastructure for testing. No new libraries or utilities are needed. The work is writing the test cases, not setting up tooling.

## Common Pitfalls

### Pitfall 1: Vitest Config Missing Pipeline Test Pattern
**What goes wrong:** The current `vitest.config.mts` has `include: ["src/**/*.test.{ts,tsx}"]` but the CLAUDE.md convention states the pattern is `src/**/*.test.{ts,tsx}` + `scripts/**/*.test.ts`. Pipeline tests in `scripts/` will not run.
**Why it happens:** The vitest config was not updated when the pipeline convention was established.
**How to avoid:** Add `"scripts/**/*.test.ts"` to the `include` array in `vitest.config.mts`. Ensure `scripts/**/*.test.ts` files import from relative paths (not `@/*` aliases, since those resolve to `src/*`).
**Warning signs:** `pnpm test` shows 0 tests discovered for pipeline scripts.

### Pitfall 2: Env Module Import Side Effects
**What goes wrong:** Importing any module that transitively imports `@/lib/env` causes `@t3-oss/env-nextjs` to validate environment variables, throwing errors in test environment.
**Why it happens:** `createEnv` validates `DATABASE_URL`, `BETTER_AUTH_SECRET`, etc. at import time.
**How to avoid:** Always `vi.mock("@/lib/env")` before importing modules that depend on env. For the upload route test, mock both `@/lib/env` and `@/db` (which imports env). The CI workflow already sets `DATABASE_URL` to a dummy value and `NODE_ENV=test`.
**Warning signs:** Tests fail with "Invalid environment variables" error immediately.

### Pitfall 3: Module Mock Hoisting
**What goes wrong:** `vi.mock()` calls must be at the top level (not inside describe/it blocks) because Vitest hoists them above all imports. Placing mocks after imports means the original module runs first.
**Why it happens:** Vitest transforms code to hoist vi.mock() calls. If you define the mock after import, the import already ran with the real module.
**How to avoid:** Always place `vi.mock()` calls before the imports they mock. For dynamic mock values, use `vi.fn()` at module scope and configure in `beforeEach`.
**Warning signs:** Mocked functions return `undefined` or the real implementation runs.

### Pitfall 4: React Hook Form in Tests
**What goes wrong:** Testing components that use `useFormContext()` (like StepPhysical, StepGoal, etc.) without wrapping them in a FormProvider.
**Why it happens:** These are sub-components of the wizard that rely on FormProvider context from the parent.
**How to avoid:** Test the OnboardingWizard as the integration point (it provides FormProvider). Test individual steps only if the wizard test becomes too large, and wrap them in a FormProvider with useForm.
**Warning signs:** Error: "useFormContext must be used within a FormProvider".

### Pitfall 5: useTransition and startTransition in Tests
**What goes wrong:** `startTransition` wraps router.push() calls but doesn't await them, making the push asynchronous. Tests that check mockPush.toHaveBeenCalledWith() immediately after triggering an action may fail.
**Why it happens:** React 19's startTransition defers state updates. In jsdom environment, the transition may not flush synchronously.
**How to avoid:** Use `vi.useFakeTimers()` to control debounce, then `await act(async () => { ... })` to flush transitions. For components with debounce (SearchBar, TagFilter), advance timers then wait for the act to complete.
**Warning signs:** Tests pass sometimes but not others (timing-dependent).

### Pitfall 6: Pipeline Tests Path Aliases
**What goes wrong:** Pipeline test files in `scripts/pipeline/lib/__tests__/` cannot use `@/*` path aliases because `@/*` maps to `./src/*`, not project root.
**Why it happens:** The `paths` config in tsconfig.json defines `@/*` -> `./src/*`.
**How to avoid:** Pipeline tests must use relative imports only (e.g., `import { extractJowId } from "../jow-parser"`). Only `src/` tests can use `@/*` aliases.
**Warning signs:** "Cannot find module '@/...'" errors in pipeline tests.

### Pitfall 7: DB Integration Test Cleanup Order
**What goes wrong:** Truncating tables in wrong order fails due to foreign key constraints.
**Why it happens:** recipe_ingredients references recipes, recipe_tags references recipes.
**How to avoid:** Use `cleanupTestDb()` which does `TRUNCATE ... CASCADE` for each table. This is already implemented correctly.
**Warning signs:** Foreign key constraint violations during test cleanup.

### Pitfall 8: Mocking authClient for Form Components
**What goes wrong:** LoginForm and RegisterForm import `authClient` from `@/lib/auth-client`, which calls `createAuthClient()` from `better-auth/react`. This may fail in jsdom if better-auth tries to access browser-only APIs.
**Why it happens:** `better-auth/react` may reference window, fetch, or cookies during initialization.
**How to avoid:** Mock `@/lib/auth-client` entirely:
```typescript
vi.mock("@/lib/auth-client", () => ({
  authClient: {
    signIn: { email: vi.fn() },
    signUp: { email: vi.fn() },
  },
}));
```
**Warning signs:** "ReferenceError: fetch is not defined" or similar browser API errors.

## Code Examples

### Test File Template (Pipeline Pure Functions)
```typescript
// scripts/pipeline/lib/__tests__/jow-parser.test.ts
import { describe, expect, it } from "vitest";
import {
  extractJowId,
  extractRecipeSlug,
  parseIsoDuration,
  parseNextDataRecipe,
  parseJsonLdRecipe,
} from "../jow-parser";

describe("extractJowId", () => {
  it("extracts ID from full URL", () => {
    expect(extractJowId("https://jow.fr/recipes/poulet-au-curry-89y06dxjhfua0twu16x5"))
      .toBe("89y06dxjhfua0twu16x5");
  });

  it("extracts ID from relative path", () => {
    expect(extractJowId("/recipes/poulet-au-curry-89y06dxjhfua0twu16x5"))
      .toBe("89y06dxjhfua0twu16x5");
  });

  it("returns full segment if no dash", () => {
    expect(extractJowId("/recipes/onlysegment")).toBe("onlysegment");
  });
});

describe("extractRecipeSlug", () => {
  it("extracts slug without ID", () => {
    expect(extractRecipeSlug("https://jow.fr/recipes/poulet-au-curry-89y06dxjhfua0twu16x5"))
      .toBe("poulet-au-curry");
  });
});

describe("parseIsoDuration", () => {
  const cases: [string, number | null][] = [
    ["PT30M", 30],
    ["PT1H15M", 75],
    ["PT1H", 60],
    ["PT2H30M", 150],
    ["PT0S", null],       // 0 total returns null
    ["", null],           // empty string
    ["30 minutes", null], // non-ISO format
    ["pt30m", 30],        // case insensitive
  ];

  it.each(cases)("parseIsoDuration(%s) = %s", (input, expected) => {
    expect(parseIsoDuration(input)).toBe(expected);
  });
});
```

### Test File Template (Impure Function with Mocks)
```typescript
// scripts/pipeline/lib/__tests__/claude-enricher.test.ts
import { describe, expect, it, vi, beforeEach } from "vitest";

// Must mock child_process, fs, os, crypto before importing
vi.mock("node:child_process", () => ({ execSync: vi.fn() }));
vi.mock("node:fs", () => ({
  readFileSync: vi.fn(),
  writeFileSync: vi.fn(),
  unlinkSync: vi.fn(),
}));
vi.mock("node:os", () => ({ tmpdir: () => "/tmp" }));
vi.mock("node:crypto", () => ({ randomUUID: () => "mock-uuid" }));

import { execSync } from "node:child_process";
import { readFileSync } from "node:fs";

// Now import the module under test
import { enrichRecipe } from "../claude-enricher";

describe("enrichRecipe", () => {
  beforeEach(() => {
    vi.restoreAllMocks();
    // Mock readFileSync for prompt file
    vi.mocked(readFileSync).mockReturnValue("system prompt content");
  });

  it("parses structured_output from Claude CLI", () => {
    const mockOutput = JSON.stringify({
      structured_output: {
        ingredients: [
          { name: "poulet", proteinPer100g: 25, carbsPer100g: 0, fatPer100g: 3, caloriesPer100g: 130, confidence: "high" },
        ],
      },
    });
    vi.mocked(execSync).mockReturnValue(mockOutput);

    const result = enrichRecipe(/* minimal ScrapedRecipe */);
    expect(result).toHaveLength(1);
    expect(result[0].name).toBe("poulet");
  });
});
```

### Test File Template (React Component with Router Mock)
```typescript
// src/components/__tests__/tag-filter.test.tsx
import { render, screen, fireEvent } from "@testing-library/react";
import { describe, expect, it, vi, beforeEach } from "vitest";

const mockPush = vi.fn();
vi.mock("next/navigation", () => ({
  useRouter: () => ({ push: mockPush }),
  usePathname: () => "/recipes",
  useSearchParams: () => new URLSearchParams(""),
}));

import { TagFilter } from "../tag-filter";

const TAGS = [
  { id: "1", name: "Rapide", slug: "rapide" },
  { id: "2", name: "Facile", slug: "facile" },
];

describe("TagFilter", () => {
  beforeEach(() => {
    mockPush.mockClear();
  });

  it("renders nothing when tags is empty", () => {
    const { container } = render(<TagFilter tags={[]} activeSlugs={[]} />);
    expect(container.firstChild).toBeNull();
  });

  it("renders all tags", () => {
    render(<TagFilter tags={TAGS} activeSlugs={[]} />);
    expect(screen.getByText("Rapide")).toBeInTheDocument();
    expect(screen.getByText("Facile")).toBeInTheDocument();
  });

  it("toggles a tag on click", () => {
    render(<TagFilter tags={TAGS} activeSlugs={[]} />);
    fireEvent.click(screen.getByText("Rapide"));
    // startTransition wraps the push -- may need act()
  });
});
```

### Test File Template (Zod Profile Schema)
```typescript
// src/lib/schemas/__tests__/profile.test.ts
import { describe, expect, it } from "vitest";
import { physicalSchema, goalSchema, profileSchema } from "../profile";

describe("physicalSchema", () => {
  it("accepts valid data", () => {
    const result = physicalSchema.safeParse({
      weight: 70, height: 175, age: 30,
      sex: "homme", activityLevel: "actif",
    });
    expect(result.success).toBe(true);
  });

  it("rejects weight below 30", () => {
    const result = physicalSchema.safeParse({
      weight: 29, height: 175, age: 30,
      sex: "homme", activityLevel: "actif",
    });
    expect(result.success).toBe(false);
  });

  it("rejects weight above 300", () => {
    const result = physicalSchema.safeParse({
      weight: 301, height: 175, age: 30,
      sex: "homme", activityLevel: "actif",
    });
    expect(result.success).toBe(false);
  });

  it("rejects invalid sex enum value", () => {
    const result = physicalSchema.safeParse({
      weight: 70, height: 175, age: 30,
      sex: "invalid", activityLevel: "actif",
    });
    expect(result.success).toBe(false);
  });
});
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Vitest 1.x `vi.mocked()` requires type assertion | Vitest 4.x `vi.mocked()` infers types automatically | Vitest 4.0 (2025) | Cleaner mock typing |
| `@testing-library/jest-dom` manual import | `@testing-library/jest-dom/vitest` auto-extends | jest-dom 6.x | Already set up in `src/test/setup.ts` |
| Separate test setup per framework | Vitest `globals: true` + `setupFiles` | Vitest convention | Already configured -- describe/it/expect available globally |

**Deprecated/outdated:**
- `enzyme`: Replaced by @testing-library/react years ago. Not relevant here.
- `ts-jest`: Vitest handles TypeScript natively via Vite transform. No need for ts-jest.

## Important Codebase-Specific Findings

### Vitest Config Gap
The `vitest.config.mts` `include` array currently only has `["src/**/*.test.{ts,tsx}"]`. The CLAUDE.md convention says pattern should also include `scripts/**/*.test.ts`. **This must be fixed** or pipeline tests will not run.

### Functions to Test -- Inventory

#### Pure Functions (No Mocks Needed)
| File | Functions | Test Priority |
|------|-----------|--------------|
| `scripts/pipeline/lib/jow-parser.ts` | `extractJowId`, `extractRecipeSlug`, `parseIsoDuration`, `parseNextDataRecipe`, `parseJsonLdRecipe` | HIGH -- complex parsing with many edge cases |
| `scripts/pipeline/lib/claude-enricher.ts` | `parseClaudeOutput` (private but testable via enrichRecipe), `validateIngredients`, `boundsCheck`, `crossValidateNutrition` | HIGH -- nutrition validation logic |
| `scripts/pipeline/lib/recipe-assembler.ts` | `assembleEnrichedRecipe` | MEDIUM -- join logic |
| `scripts/pipeline/lib/schemas.ts` | All schemas (boundary testing) | HIGH -- data contract enforcement |
| `src/lib/schemas/profile.ts` | `physicalSchema`, `goalSchema`, `dietarySchema`, `sportSchema`, `profileSchema` | HIGH -- user input validation |
| `src/app/api/recipes/upload/route.ts` | `slugify` (private), upload schemas | MEDIUM -- tested indirectly via POST handler |

#### Impure Functions (Mocks Needed)
| File | Functions | Mock Target |
|------|-----------|------------|
| `scripts/pipeline/lib/jsonl.ts` | `readJsonl`, `writeJsonl`, `appendJsonl`, `countLines` | `node:fs` (createReadStream, writeFile, appendFile) |
| `scripts/pipeline/lib/api-client.ts` | `createApiClient.uploadRecipe` | `globalThis.fetch` |
| `scripts/pipeline/lib/claude-enricher.ts` | `enrichRecipe`, `enrichRecipeWithRetry`, `enrichIngredientBatch` | `node:child_process` (execSync), `node:fs` |
| `scripts/pipeline/lib/ingredient-extractor.ts` | `extractUniqueIngredients` | Mock `readJsonl` |

#### React Components
| Component | Key Behaviors to Test | Mocks Needed |
|-----------|----------------------|-------------|
| `SearchBar` | Renders with defaultValue, debounces 300ms, updates URL params | `next/navigation` |
| `TagFilter` | Renders tags, toggles active state, adds/removes URL params | `next/navigation` |
| `PaginationControls` | Hides when totalPages <= 1, renders page entries, builds correct hrefs | `next/navigation` |
| `LoginForm` | Renders fields, validates email/password, calls authClient.signIn | `next/navigation`, `@/lib/auth-client` |
| `RegisterForm` | Renders fields, validates password match, calls authClient.signUp + signIn | `next/navigation`, `@/lib/auth-client` |
| `OnboardingWizard` | Multi-step navigation, validates per step, calls saveProfile server action | `next/navigation`, `@/app/actions/profile`, `sonner` |

#### API Route
| Route | Key Behaviors to Test | Mocks Needed |
|-------|----------------------|-------------|
| `POST /api/recipes/upload` | Auth (401 without/wrong token), validation (400 on bad body), success path (201) | `@/db`, `@/lib/env` |

#### DB Integration Queries
| File | Functions | Test Against |
|------|-----------|-------------|
| `src/db/queries/recipes.ts` | `getRecipes` (pagination, search, tag filter), `getRecipeById` (UUID validation, with relations) | Test DB (port 5434) |
| `src/db/queries/profiles.ts` | `upsertUserProfile`, `getUserProfile`, `setUserDietaryPreferences`, `isProfileComplete` | Test DB (port 5434) |
| `src/db/queries/tags.ts` | `getAllTags` | Test DB (port 5434) |

### Private Functions That Need Testing
Several important functions in `claude-enricher.ts` and `route.ts` are not exported:
- `parseClaudeOutput` -- critical parsing logic
- `validateIngredients` -- Zod validation wrapper
- `boundsCheck` -- sanity check for macro values
- `slugify` -- tag slug generation

**Recommendation:** Either export these functions (preferred, since they are pure and testable independently) or test them indirectly through the exported functions. The enricher functions (`parseClaudeOutput`, `validateIngredients`, `boundsCheck`) should be exported since they represent distinct, testable logic. The `slugify` function can be tested indirectly via the POST route handler. `crossValidateNutrition` is already exported.

## Open Questions

1. **Private function exports**
   - What we know: `parseClaudeOutput`, `validateIngredients`, `boundsCheck` in claude-enricher.ts and `slugify` in route.ts are not exported
   - What's unclear: Whether to export them for direct testing or test only via public API
   - Recommendation: Export pure helper functions from claude-enricher.ts for direct testing. Keep slugify private and test via POST handler integration.

2. **JSONL test strategy**
   - What we know: `readJsonl` uses Node.js streams (createReadStream + readline) which are tricky to mock
   - What's unclear: Whether to mock at stream level or use temp files
   - Recommendation: Use temp files with `node:fs/promises` writeFile for test setup, then call real readJsonl. This tests the actual implementation. For writeJsonl/appendJsonl, write to temp directory and verify file contents. Use `vi.mock("node:fs")` only if temp file approach proves unwieldy.

3. **OnboardingWizard test complexity**
   - What we know: The wizard has 4 steps, react-hook-form validation per step, server action call, router navigation
   - What's unclear: How deep to test (full form submission vs. step navigation only)
   - Recommendation: Test step navigation and final submission separately. Mock `saveProfile` server action. Focus on: step renders correct content, Next/Previous navigation works, validation blocks advancement, submit calls saveProfile.

## Sources

### Primary (HIGH confidence)
- Codebase inspection: All source files read directly from the project
- `vitest.config.mts`: Confirmed Vitest 4.0.18 config with jsdom, globals, setupFiles
- `package.json`: Confirmed all testing dependencies already installed
- `tsconfig.json`: Confirmed path alias `@/*` -> `./src/*`
- `.github/workflows/deploy.yml`: Confirmed CI test command `pnpm test run --exclude 'src/db/**'`
- `src/test/setup.ts`: Confirmed @testing-library/jest-dom/vitest loaded
- `src/test/db-setup.ts`: Confirmed test DB utilities (setupTestDb, cleanupTestDb, closeTestDb)

### Secondary (MEDIUM confidence)
- Vitest 4.x `vi.mock()` hoisting behavior -- based on Vitest docs + training data for v4.x
- React Testing Library patterns for React 19 + react-hook-form -- training data confirms these patterns work

### Tertiary (LOW confidence)
- None. All findings verified against actual codebase inspection.

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH -- all libraries already installed and configured, versions verified in package.json
- Architecture: HIGH -- patterns derived from existing codebase conventions (CLAUDE.md, existing tests)
- Pitfalls: HIGH -- identified from actual code analysis (env side effects, vitest config gap, private functions)

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (30 days -- stable stack, no expected major changes)
