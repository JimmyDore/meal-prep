---
phase: 04-authentication-user-profile
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/db/schema/profiles.ts
  - src/db/schema/dietary-preferences.ts
  - src/db/schema/sport-activities.ts
  - src/db/schema/index.ts
  - src/db/queries/profiles.ts
  - src/lib/schemas/profile.ts
autonomous: true

must_haves:
  truths:
    - "User profile table stores physical info (weight, height, age, sex, activityLevel), goal, and householdSize"
    - "Dietary preferences table stores per-user exclusion selections"
    - "Sport activities table stores per-user activity type + weekly frequency"
    - "All profile data is linked to userId (FK to Better Auth user table)"
    - "Profile data can be upserted (create or update) per user"
  artifacts:
    - path: "src/db/schema/profiles.ts"
      provides: "User profile table with physical info, goal, householdSize"
      contains: "pgTable"
    - path: "src/db/schema/dietary-preferences.ts"
      provides: "Dietary preferences join table (user x preference)"
      contains: "pgTable"
    - path: "src/db/schema/sport-activities.ts"
      provides: "Sport activities table (user x activity type + frequency)"
      contains: "pgTable"
    - path: "src/db/queries/profiles.ts"
      provides: "CRUD functions for profile, preferences, and sport activities"
      exports: ["getUserProfile", "upsertUserProfile", "getUserDietaryPreferences", "setUserDietaryPreferences", "getUserSportActivities", "setUserSportActivities"]
    - path: "src/lib/schemas/profile.ts"
      provides: "Zod validation schemas for profile form data"
      exports: ["profileSchema", "ProfileFormData"]
  key_links:
    - from: "src/db/schema/profiles.ts"
      to: "src/db/schema/auth.ts"
      via: "userId FK reference"
      pattern: "references.*user"
    - from: "src/db/queries/profiles.ts"
      to: "src/db/schema/profiles.ts"
      via: "drizzle query"
      pattern: "import.*profiles"
---

<objective>
Create database schema and query layer for user profiles, dietary preferences, and sport activities.

Purpose: Data layer for the onboarding wizard and settings page. All user configuration data persisted in Postgres.
Output: 3 new DB tables + query functions + Zod validation schemas.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-authentication-user-profile/04-RESEARCH.md
@.planning/phases/04-authentication-user-profile/04-CONTEXT.md
@.planning/phases/04-authentication-user-profile/04-01-SUMMARY.md
@src/db/schema/common.ts
@src/db/schema/index.ts
@src/db/schema/auth.ts
@src/db/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Profile, dietary preferences, and sport activities schemas</name>
  <files>
    src/db/schema/profiles.ts
    src/db/schema/dietary-preferences.ts
    src/db/schema/sport-activities.ts
    src/db/schema/index.ts
  </files>
  <action>
**1. Create `src/db/schema/profiles.ts`:**

Table `user_profiles` with columns:
- `id` (uuid, PK, default random) — use idColumn from common.ts
- `userId` (text, NOT NULL, unique, FK to user table from auth.ts) — text because Better Auth uses text IDs
- `weight` (real) — poids in kg
- `height` (real) — taille in cm
- `age` (integer) — age in years
- `sex` (text, pgEnum or check) — "homme" | "femme"
- `activityLevel` (text) — "sedentaire" | "legerement_actif" | "moderement_actif" | "actif" | "tres_actif"
- `goal` (text) — "seche" | "maintien" | "prise_de_masse" | "recomposition"
- `householdSize` (integer, default 1) — nombre de personnes (1-6)
- `mealsPerDay` (integer, default 2) — fixed at 2 for v1 (lunch + dinner)
- timestamps from common.ts

Use `pgEnum` for sex, activityLevel, and goal columns to enforce valid values at DB level:
```typescript
export const sexEnum = pgEnum("sex", ["homme", "femme"]);
export const activityLevelEnum = pgEnum("activity_level", ["sedentaire", "legerement_actif", "moderement_actif", "actif", "tres_actif"]);
export const goalEnum = pgEnum("goal", ["seche", "maintien", "prise_de_masse", "recomposition"]);
```

Add relations: userProfiles belongs to user (via userId).

**2. Create `src/db/schema/dietary-preferences.ts`:**

Table `user_dietary_preferences` with columns:
- `id` (uuid, PK) — idColumn
- `userId` (text, NOT NULL, FK to user) — NOT unique (one row per preference)
- `preference` (text, NOT NULL) — one of: "vegetarien" | "vegan" | "sans_gluten" | "sans_lactose" | "sans_porc" | "halal" | "sans_fruits_de_mer"
- timestamps
- Unique constraint on (userId, preference) to prevent duplicates

Use `pgEnum` for preference:
```typescript
export const dietaryPreferenceEnum = pgEnum("dietary_preference", [
  "vegetarien", "vegan", "sans_gluten", "sans_lactose", "sans_porc", "halal", "sans_fruits_de_mer"
]);
```

**3. Create `src/db/schema/sport-activities.ts`:**

Table `user_sport_activities` with columns:
- `id` (uuid, PK) — idColumn
- `userId` (text, NOT NULL, FK to user)
- `activityType` (text, NOT NULL) — one of: "course" | "musculation" | "natation" | "velo" | "yoga" | "marche" | "sport_collectif"
- `weeklyFrequency` (integer, NOT NULL) — times per week (1-7)
- timestamps
- Unique constraint on (userId, activityType) — one entry per activity type per user

Use `pgEnum` for activityType:
```typescript
export const activityTypeEnum = pgEnum("activity_type", [
  "course", "musculation", "natation", "velo", "yoga", "marche", "sport_collectif"
]);
```

**4. Update `src/db/schema/index.ts`:**
Add exports for all 3 new schema files:
```typescript
export * from "./profiles";
export * from "./dietary-preferences";
export * from "./sport-activities";
```

**5. Push schema to dev DB:**
```bash
pnpm db:push
```

Verify tables exist:
```bash
docker compose exec -T db psql -U mealprep -d mealprep -c "\dt"
docker compose exec -T db psql -U mealprep -d mealprep -c "\dT+"
```
Should show user_profiles, user_dietary_preferences, user_sport_activities tables and the new enum types.
  </action>
  <verify>
1. `pnpm db:push` succeeds
2. `docker compose exec -T db psql -U mealprep -d mealprep -c "\dt"` shows 3 new tables
3. `pnpm build` succeeds (no type errors from schema exports)
  </verify>
  <done>3 new tables in Postgres: user_profiles, user_dietary_preferences, user_sport_activities. All linked to user table via userId FK. Enum types enforce valid values.</done>
</task>

<task type="auto">
  <name>Task 2: Zod validation schemas + DB query functions</name>
  <files>
    src/lib/schemas/profile.ts
    src/db/queries/profiles.ts
  </files>
  <action>
**1. Create `src/lib/schemas/profile.ts`:**

Zod schema for the full onboarding form:
```typescript
import { z } from "zod";

export const sexValues = ["homme", "femme"] as const;
export const activityLevelValues = ["sedentaire", "legerement_actif", "moderement_actif", "actif", "tres_actif"] as const;
export const goalValues = ["seche", "maintien", "prise_de_masse", "recomposition"] as const;
export const dietaryPreferenceValues = ["vegetarien", "vegan", "sans_gluten", "sans_lactose", "sans_porc", "halal", "sans_fruits_de_mer"] as const;
export const activityTypeValues = ["course", "musculation", "natation", "velo", "yoga", "marche", "sport_collectif"] as const;

// Step 1: Physical info
export const physicalSchema = z.object({
  weight: z.number().min(30).max(300),     // kg
  height: z.number().min(100).max(250),    // cm
  age: z.number().int().min(14).max(100),
  sex: z.enum(sexValues),
  activityLevel: z.enum(activityLevelValues),
});

// Step 2: Goal + household
export const goalSchema = z.object({
  goal: z.enum(goalValues),
  householdSize: z.number().int().min(1).max(6),
});

// Step 3: Dietary preferences
export const dietarySchema = z.object({
  dietaryPreferences: z.array(z.enum(dietaryPreferenceValues)),
});

// Step 4: Sport activities
export const sportActivitySchema = z.object({
  activityType: z.enum(activityTypeValues),
  weeklyFrequency: z.number().int().min(1).max(7),
});

export const sportSchema = z.object({
  sportActivities: z.array(sportActivitySchema),
});

// Full profile schema (all steps combined)
export const profileSchema = physicalSchema.merge(goalSchema).merge(dietarySchema).merge(sportSchema);

export type ProfileFormData = z.infer<typeof profileSchema>;
export type SportActivity = z.infer<typeof sportActivitySchema>;
```

Also export French display labels for each enum value:
```typescript
export const activityLevelLabels: Record<typeof activityLevelValues[number], string> = {
  sedentaire: "Sedentaire",
  legerement_actif: "Legerement actif",
  moderement_actif: "Moderement actif",
  actif: "Actif",
  tres_actif: "Tres actif",
};

export const goalLabels: Record<typeof goalValues[number], string> = {
  seche: "Seche",
  maintien: "Maintien",
  prise_de_masse: "Prise de masse",
  recomposition: "Recomposition",
};

export const dietaryPreferenceLabels: Record<typeof dietaryPreferenceValues[number], string> = {
  vegetarien: "Vegetarien",
  vegan: "Vegan",
  sans_gluten: "Sans gluten",
  sans_lactose: "Sans lactose",
  sans_porc: "Sans porc",
  halal: "Halal",
  sans_fruits_de_mer: "Sans fruits de mer",
};

export const activityTypeLabels: Record<typeof activityTypeValues[number], string> = {
  course: "Course / Running",
  musculation: "Musculation",
  natation: "Natation",
  velo: "Velo",
  yoga: "Yoga",
  marche: "Marche",
  sport_collectif: "Sport collectif",
};
```

**2. Create `src/db/queries/profiles.ts`:**

Query functions with application-level userId filtering:

- `getUserProfile(userId: string)` — SELECT from user_profiles WHERE userId = ?
- `upsertUserProfile(userId: string, data)` — INSERT ... ON CONFLICT(userId) DO UPDATE
- `getUserDietaryPreferences(userId: string)` — SELECT from user_dietary_preferences WHERE userId = ?
- `setUserDietaryPreferences(userId: string, preferences: string[])` — DELETE all for userId, then INSERT new ones (transaction)
- `getUserSportActivities(userId: string)` — SELECT from user_sport_activities WHERE userId = ?
- `setUserSportActivities(userId: string, activities: {activityType, weeklyFrequency}[])` — DELETE all for userId, then INSERT new ones (transaction)
- `getFullUserProfile(userId: string)` — Returns profile + preferences + activities in one call
- `isProfileComplete(userId: string)` — Returns boolean (checks if user_profiles row exists with all required fields non-null)

Use Drizzle's `db.transaction()` for the set* functions to ensure atomicity.

All functions use `eq(table.userId, userId)` for data isolation — a user can only access their own data.
  </action>
  <verify>
1. `pnpm build` succeeds
2. Types are correctly inferred (no `any` in query return types)
  </verify>
  <done>Zod schemas validate all profile form data with French enum values. DB query layer provides CRUD for profiles, dietary preferences, and sport activities with application-level userId isolation.</done>
</task>

</tasks>

<verification>
- 3 new DB tables with proper enums and constraints
- Zod schemas validate all form inputs
- Query functions handle CRUD with userId filtering
- `pnpm build` passes
</verification>

<success_criteria>
All profile data can be stored and retrieved per user. Schema enforces valid values via pgEnum. Query functions use userId filtering for data isolation. Zod schemas ready for form validation in Plan 04.
</success_criteria>

<output>
After completion, create `.planning/phases/04-authentication-user-profile/04-03-SUMMARY.md`
</output>
