---
phase: 06-basic-meal-plan-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema/meal-plans.ts
  - src/db/schema/index.ts
  - src/db/queries/meal-plans.ts
  - drizzle/XXXX-meal-plans.sql
autonomous: true

must_haves:
  truths:
    - "meal_plans table stores saved plans with userId, weekStart, overallScore, macroSummary"
    - "meal_plan_slots table stores 14 slots per plan with dayIndex, mealType, recipeId, macrosSnapshot"
    - "getAllRecipesWithIngredients returns all recipes joined with their ingredients in a single query"
    - "saveMealPlan inserts plan + 14 slots in a single transaction"
    - "getUserMealPlan fetches the most recent plan for a user with all slots and recipe data"
  artifacts:
    - path: "src/db/schema/meal-plans.ts"
      provides: "mealTypeEnum, mealPlans table, mealPlanSlots table, relations"
      contains: "pgEnum"
      min_lines: 40
    - path: "src/db/queries/meal-plans.ts"
      provides: "getAllRecipesWithIngredients, saveMealPlan, getUserMealPlan"
      exports: ["getAllRecipesWithIngredients", "saveMealPlan", "getUserMealPlan"]
      min_lines: 50
  key_links:
    - from: "src/db/schema/meal-plans.ts"
      to: "src/db/schema/auth.ts"
      via: "userId references user.id"
      pattern: "references.*user\\.id"
    - from: "src/db/schema/meal-plans.ts"
      to: "src/db/schema/recipes.ts"
      via: "recipeId references recipes.id"
      pattern: "references.*recipes\\.id"
    - from: "src/db/queries/meal-plans.ts"
      to: "src/db/schema/meal-plans.ts"
      via: "imports mealPlans, mealPlanSlots for CRUD"
      pattern: "import.*mealPlans.*from.*schema"
---

<objective>
Create the database schema and query layer for meal plans -- two new tables (meal_plans, meal_plan_slots) with a Drizzle migration, plus query functions for fetching the recipe pool and saving/loading plans.

Purpose: The DB layer stores generated meal plans and provides the recipe pool data that the generation algorithm needs.
Output: Schema file, migration SQL, and query functions ready for server actions.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-basic-meal-plan-generation/06-RESEARCH.md
@src/db/schema/common.ts
@src/db/schema/recipes.ts
@src/db/schema/ingredients.ts
@src/db/schema/auth.ts
@src/db/schema/index.ts
@src/db/queries/recipes.ts
@src/db/queries/profiles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meal plan schema and migration</name>
  <files>
    src/db/schema/meal-plans.ts
    src/db/schema/index.ts
  </files>
  <action>
    Create `src/db/schema/meal-plans.ts` with:

    1. **mealTypeEnum** -- `pgEnum("meal_type", ["midi", "soir"])`. This follows the project convention of pgEnum for all constrained values (see 04-03 decision).

    2. **mealPlans** table:
       ```
       - ...idColumn (uuid PK)
       - userId: text().notNull().references(() => user.id, { onDelete: "cascade" })
       - weekStart: text().notNull()  // ISO date string e.g. "2026-02-10"
       - overallScore: real().notNull()  // 0-100 match percentage
       - macroSummary: jsonb().notNull()  // { target: WeeklyMacroTargets, actual: { calories, protein, carbs, fat } }
       - ...timestamps
       ```

    3. **mealPlanSlots** table:
       ```
       - ...idColumn (uuid PK)
       - planId: uuid().notNull().references(() => mealPlans.id, { onDelete: "cascade" })
       - dayIndex: integer().notNull()  // 0 (Lundi) to 6 (Dimanche)
       - mealType: mealTypeEnum().notNull()  // "midi" or "soir"
       - recipeId: uuid().notNull().references(() => recipes.id)
       - macrosSnapshot: jsonb().notNull()  // { calories, protein, carbs, fat } at generation time
       - ...timestamps
       ```

    4. **Relations:**
       - mealPlans -> many mealPlanSlots
       - mealPlanSlots -> one mealPlans, one recipes

    Import `user` from `./auth`, `recipes` from `./recipes`, `idColumn, timestamps` from `./common`.
    Use `real()` for overallScore (consistent with existing schema pattern for nutrients).

    Update `src/db/schema/index.ts` to add: `export * from "./meal-plans";`

    Then run: `pnpm db:generate` to create the migration file.
    Then run: `pnpm db:push` to apply to dev DB.

    **Important:** DB columns use snake_case (handled by `casing: "snake_case"` in drizzle.config.ts), TypeScript fields use camelCase. Do NOT manually specify column names -- Drizzle handles the mapping.
  </action>
  <verify>
    - `pnpm db:generate` completes without error and creates a new migration SQL file in `drizzle/`
    - `pnpm db:push` applies schema to dev DB without error
    - `docker compose exec -T db psql -U mealprep -d mealprep -c "\dt"` shows `meal_plans` and `meal_plan_slots` tables
    - `pnpm check` passes
  </verify>
  <done>
    meal_plans and meal_plan_slots tables exist in dev DB with correct columns, foreign keys, and constraints. Migration file exists in drizzle/ directory.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create meal plan query functions</name>
  <files>
    src/db/queries/meal-plans.ts
  </files>
  <action>
    Create `src/db/queries/meal-plans.ts` with three query functions:

    1. **getAllRecipesWithIngredients()** -- Fetches ALL recipes with their ingredients for the generation algorithm. Uses Drizzle relational query (same pattern as getRecipeById in recipes.ts):
       ```typescript
       export async function getAllRecipesWithIngredients() {
         return db.query.recipes.findMany({
           with: {
             recipeIngredients: {
               with: {
                 ingredient: true,
               },
             },
           },
         });
       }
       ```
       This returns recipes with nested recipeIngredients[].ingredient objects, which the server action will transform into ScoredRecipe[] using calculateRecipeMacros.

    2. **saveMealPlan(data)** -- Saves a plan with its 14 slots in a single transaction:
       ```typescript
       export async function saveMealPlan(data: {
         userId: string;
         weekStart: string;
         overallScore: number;
         macroSummary: unknown;  // JSONB -- typed as unknown at DB layer, validated at action layer
         slots: Array<{
           dayIndex: number;
           mealType: "midi" | "soir";
           recipeId: string;
           macrosSnapshot: unknown;  // JSONB
         }>;
       }) {
         return db.transaction(async (tx) => {
           const [plan] = await tx.insert(mealPlans).values({
             userId: data.userId,
             weekStart: data.weekStart,
             overallScore: data.overallScore,
             macroSummary: data.macroSummary,
           }).returning();

           if (data.slots.length > 0) {
             await tx.insert(mealPlanSlots).values(
               data.slots.map((slot) => ({
                 planId: plan.id,
                 dayIndex: slot.dayIndex,
                 mealType: slot.mealType,
                 recipeId: slot.recipeId,
                 macrosSnapshot: slot.macrosSnapshot,
               })),
             );
           }

           return plan;
         });
       }
       ```

    3. **getUserMealPlan(userId)** -- Fetches the most recent plan for a user with all slots and recipe titles (for displaying a saved plan):
       ```typescript
       export async function getUserMealPlan(userId: string) {
         return db.query.mealPlans.findFirst({
           where: eq(mealPlans.userId, userId),
           orderBy: desc(mealPlans.createdAt),
           with: {
             mealPlanSlots: {
               with: {
                 recipe: true,  // need title and imageUrl for display
               },
             },
           },
         });
       }
       ```

    Import from: `@/db` (db instance), `@/db/schema/meal-plans` (tables), `drizzle-orm` (eq, desc).
  </action>
  <verify>
    - `pnpm check` passes (no lint/type errors)
    - `pnpm build` completes without errors (type-checks all imports)
  </verify>
  <done>
    Three query functions exist: getAllRecipesWithIngredients (batch recipe+ingredient fetch), saveMealPlan (transactional insert), getUserMealPlan (load most recent plan with slots). All typed correctly against the schema.
  </done>
</task>

</tasks>

<verification>
- `pnpm db:generate` produced migration
- Dev DB has both new tables with correct columns
- `pnpm check` passes
- `pnpm build` passes
- No N+1 query pattern -- getAllRecipesWithIngredients uses a single relational query
</verification>

<success_criteria>
- meal_plans and meal_plan_slots tables created with proper foreign keys (userId -> user, recipeId -> recipes, planId -> meal_plans)
- mealTypeEnum pgEnum created with ["midi", "soir"]
- Migration file exists in drizzle/
- getAllRecipesWithIngredients returns recipes with nested ingredient data in one query
- saveMealPlan wraps plan + slots insert in a transaction
- getUserMealPlan fetches most recent plan ordered by createdAt desc
</success_criteria>

<output>
After completion, create `.planning/phases/06-basic-meal-plan-generation/06-02-SUMMARY.md`
</output>
