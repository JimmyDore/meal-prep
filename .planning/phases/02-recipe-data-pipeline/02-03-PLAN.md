---
phase: 02-recipe-data-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - scripts/pipeline/enrich.ts
  - scripts/pipeline/lib/claude-enricher.ts
  - scripts/pipeline/prompts/macro-enrichment.md
autonomous: true

must_haves:
  truths:
    - "Running `tsx scripts/pipeline/enrich.ts` reads scraped JSONL, enriches each recipe with per-ingredient macros via Claude CLI, and writes enriched JSONL"
    - "Claude CLI is called with --json-schema for structured output and --max-turns 1 for cost control"
    - "Enrichment validates output with Zod (macro bounds: protein/carbs/fat 0-100, calories 0-900)"
    - "Enrichment retries once if macros seem aberrant, then flags for review"
    - "Enrichment skips already-enriched recipes (resumability)"
    - "Cross-validation compares Claude estimates with Jow per-serving nutrition when available"
  artifacts:
    - path: "scripts/pipeline/enrich.ts"
      provides: "Main enrichment entry point"
      min_lines: 40
    - path: "scripts/pipeline/lib/claude-enricher.ts"
      provides: "Claude CLI invocation wrapper with retry, validation, cross-validation"
      min_lines: 80
    - path: "scripts/pipeline/prompts/macro-enrichment.md"
      provides: "Prompt for Claude to estimate macros per ingredient per 100g"
      min_lines: 15
  key_links:
    - from: "scripts/pipeline/enrich.ts"
      to: "data/scraped/jow-recipes.jsonl"
      via: "readJsonl input"
      pattern: "readJsonl.*scraped"
    - from: "scripts/pipeline/enrich.ts"
      to: "data/enriched/jow-recipes-enriched.jsonl"
      via: "appendJsonl output"
      pattern: "appendJsonl.*enriched"
    - from: "scripts/pipeline/lib/claude-enricher.ts"
      to: "claude CLI"
      via: "execSync with stdin pipe"
      pattern: "execSync|execFileSync"
---

<objective>
Build the Claude CLI enrichment step that reads scraped recipes from JSONL, calls Claude to estimate per-ingredient macronutrients (protein, carbs, fat, calories per 100g), validates the output with Zod, cross-validates against Jow's per-serving nutrition, and writes enriched recipes to a new JSONL file.

Purpose: Per-ingredient macros are the core data needed for the macro calculation engine (Phase 5) and meal plan generation (Phase 6). Jow provides per-serving totals but not per-ingredient breakdowns.
Output: enrich.ts entry point + claude-enricher.ts (Claude CLI wrapper) + macro-enrichment.md (prompt)
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-recipe-data-pipeline/02-RESEARCH.md
@.planning/phases/02-recipe-data-pipeline/02-CONTEXT.md
@.planning/phases/02-recipe-data-pipeline/02-01-SUMMARY.md
@scripts/pipeline/lib/types.ts
@scripts/pipeline/lib/schemas.ts
@scripts/pipeline/lib/jsonl.ts
@scripts/pipeline/lib/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude CLI enrichment wrapper and prompt</name>
  <files>
    scripts/pipeline/lib/claude-enricher.ts
    scripts/pipeline/prompts/macro-enrichment.md
  </files>
  <action>
1. **Create `scripts/pipeline/prompts/macro-enrichment.md`** -- System prompt for Claude:
   - Instruct Claude to estimate macronutrients per 100g for each ingredient in a recipe
   - Reference standard nutritional databases (USDA, CIQUAL/table Ciqual for French ingredients)
   - For each ingredient, return: name (matching input exactly), proteinPer100g, carbsPer100g, fatPer100g, caloriesPer100g, confidence level ("high"=well-known ingredient, "medium"=common but variable, "low"=unusual or composite ingredient)
   - Instruct Claude to account for French ingredient names (Jow is a French site)
   - Instruct Claude to use the edible portion (e.g., chicken breast without bone, peeled potato)
   - Remind: calories should roughly equal `protein*4 + carbs*4 + fat*9` (sanity check)

2. **Create `scripts/pipeline/lib/claude-enricher.ts`** -- Claude CLI wrapper:

   a) Define JSON schema for `--json-schema` flag:
      ```
      {
        type: "object",
        properties: {
          ingredients: {
            type: "array",
            items: {
              type: "object",
              properties: {
                name: { type: "string" },
                proteinPer100g: { type: "number" },
                carbsPer100g: { type: "number" },
                fatPer100g: { type: "number" },
                caloriesPer100g: { type: "number" },
                confidence: { type: "string", enum: ["high", "medium", "low"] }
              },
              required: ["name", "proteinPer100g", "carbsPer100g", "fatPer100g", "caloriesPer100g", "confidence"]
            }
          }
        },
        required: ["ingredients"]
      }
      ```

   b) `enrichRecipe(recipe: ScrapedRecipe): Promise<EnrichedIngredient[]>`
      - Write recipe JSON to a temp file (avoid shell escaping issues -- use `os.tmpdir()` + `crypto.randomUUID()` for filename)
      - Build Claude CLI command: `cat "{tmpFile}" | claude -p --system-prompt-file scripts/pipeline/prompts/macro-enrichment.md --output-format json --json-schema '{schema}' --max-turns 1 --no-session-persistence --model sonnet`
      - Execute via `execSync` with `{ encoding: "utf-8", timeout: 120000 }` (2 min timeout)
      - Parse JSON output, extract `result` or root-level ingredients array (handle different Claude CLI output formats)
      - Validate each ingredient against `enrichedIngredientSchema` from schemas.ts
      - Clean up temp file in finally block
      - Return array of EnrichedIngredient

   c) `enrichRecipeWithRetry(recipe: ScrapedRecipe): Promise<{ ingredients: EnrichedIngredient[], flagged: boolean }>`
      - Calls `enrichRecipe()` first attempt
      - **Bounds check:** for each ingredient, verify:
        - protein + carbs + fat <= 100 (can't be more than 100g of macros in 100g of food)
        - calories roughly equals protein*4 + carbs*4 + fat*9 (within 20% tolerance)
        - No negative values
      - If bounds check fails: retry ONCE with modified prompt (append "Your previous estimate had aberrant values. Please re-estimate carefully.")
      - If still fails after retry: return with `flagged: true` (log for manual review)
      - Return `{ ingredients, flagged }`

   d) `crossValidateNutrition(enriched: EnrichedIngredient[], recipe: ScrapedRecipe): { valid: boolean, divergence: number }`
      - If `recipe.jowNutritionPerServing` exists (has calories/protein/carbs/fat):
        - Compute estimated per-serving totals from Claude's per-ingredient estimates:
          For each ingredient: (ingredient macros per 100g) * (quantity in recipe in grams) / 100 / (originalPortions)
          NOTE: quantity might not always be in grams -- if unit is not grams, skip this validation (too complex for now)
        - Compare with Jow's per-serving values
        - If divergence > 30% on any macro, mark as `valid: false`
      - If no Jow nutrition data, return `{ valid: true, divergence: 0 }`
      - This is a "best effort" cross-validation -- it provides signal but should not block the pipeline

   **IMPORTANT on Claude CLI output format:** The `--output-format json` flag returns JSON with a `result` key containing the structured output. Test with a simple call first to confirm the exact output structure. The structured output matching `--json-schema` may be at `parsed.result` or directly at the root. Handle both cases.

   **IMPORTANT on shell safety:** NEVER interpolate recipe data into the shell command string. Always use temp files and `cat` to pipe data via stdin. The JSON schema string is controlled by us (safe), but recipe data is user-controlled (could contain shell metacharacters).
  </action>
  <verify>
    - `scripts/pipeline/prompts/macro-enrichment.md` exists with clear instructions for macro estimation
    - `scripts/pipeline/lib/claude-enricher.ts` compiles (`pnpm tsc --noEmit`)
    - Quick manual test: create a small test script that calls `enrichRecipe()` with a single hardcoded recipe (e.g., "Poulet au curry" with chicken, rice, curry sauce) and verify it returns valid EnrichedIngredient array
    - Temp file is created and cleaned up properly
  </verify>
  <done>
    Claude CLI enrichment wrapper calls `claude -p` with temp file stdin, --json-schema for structured output, --model sonnet for cost efficiency. Validates output with Zod bounds (macros 0-100, calories 0-900). Retries once if aberrant. Cross-validates against Jow per-serving nutrition when available. Prompt instructs Claude to use USDA/CIQUAL references for French ingredients.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create enrichment entry point script</name>
  <files>
    scripts/pipeline/enrich.ts
  </files>
  <action>
1. **Create `scripts/pipeline/enrich.ts`** -- Main enrichment entry point:

   - Executable via `tsx scripts/pipeline/enrich.ts`
   - Creates logger with step name "enrich"
   - **Input:** reads `data/scraped/jow-recipes.jsonl` via `readJsonl<ScrapedRecipe>()`
   - **Resumability:** reads existing `data/enriched/jow-recipes-enriched.jsonl` if it exists, builds Set of already-enriched jowIds
   - **Processing loop:** for each scraped recipe not yet enriched:
     - Call `enrichRecipeWithRetry(recipe)`
     - Run `crossValidateNutrition()` if jowNutritionPerServing available
     - Construct EnrichedRecipe: spread ScrapedRecipe fields + add enrichedIngredients array
     - If flagged or cross-validation failed: add `_flags: string[]` field to the JSONL line (e.g., ["aberrant_macros", "cross_validation_failed"]) for later manual review
     - Append to `data/enriched/jow-recipes-enriched.jsonl` via `appendJsonl()`
     - Log progress every 10 recipes: "Enriched N/Total (X skipped, Y flagged)"
   - **Error handling per recipe:** if Claude CLI fails entirely (timeout, process error), log error, increment fail counter, continue to next recipe (don't abort pipeline)
   - **Summary:** prints final stats (success, skipped, flagged, failed, total)
   - **Exit:** exit with code 0 even if some recipes failed (partial success is expected)

   **CLI flags:**
   - `--limit N` to enrich only N recipes (for testing/cost control)
   - `--input path` to override input JSONL path (default: data/scraped/jow-recipes.jsonl)
   - `--output path` to override output JSONL path (default: data/enriched/jow-recipes-enriched.jsonl)
   - Parse with simple `process.argv` checks

   **Cost awareness:** Log a warning at startup: "This will call Claude CLI for N recipes. Estimated time: ~N*30s. Press Ctrl+C to cancel." Then `await delay(5000)` to give user time to cancel before starting enrichment. Skip the delay if `--no-delay` flag is passed.
  </action>
  <verify>
    - `tsx scripts/pipeline/enrich.ts --limit 1` processes 1 recipe from scraped JSONL, creates `data/enriched/jow-recipes-enriched.jsonl` with 1 line
    - The enriched JSONL line contains both original scraped data AND enrichedIngredients array with macro values
    - Re-running `tsx scripts/pipeline/enrich.ts --limit 1` skips already-enriched recipe (0 new, 1 skipped)
    - `pnpm tsc --noEmit` passes
  </verify>
  <done>
    Enrichment script reads scraped JSONL, calls Claude CLI for per-ingredient macros, validates with Zod bounds, retries aberrant results, cross-validates against Jow nutrition, writes enriched JSONL. Supports --limit for cost control, --no-delay for automation, resumability via jowId set. Logs progress and summary with flagged/failed counts.
  </done>
</task>

</tasks>

<verification>
- `tsx scripts/pipeline/enrich.ts --limit 2 --no-delay` enriches 2 recipes successfully
- Enriched JSONL contains enrichedIngredients with proteinPer100g/carbsPer100g/fatPer100g/caloriesPer100g for each ingredient
- Values are within bounds (protein/carbs/fat: 0-100, calories: 0-900)
- Re-run skips already-enriched recipes
- `pnpm tsc --noEmit` passes
</verification>

<success_criteria>
1. Claude CLI called with --json-schema for structured macro output, --model sonnet, --max-turns 1
2. Per-ingredient macros validated with Zod bounds (0-100 for macros, 0-900 for calories)
3. Aberrant results retried once, then flagged for review
4. Cross-validation against Jow per-serving nutrition (when available)
5. Resumability: skips already-enriched recipes
6. --limit flag for cost-controlled testing
</success_criteria>

<output>
After completion, create `.planning/phases/02-recipe-data-pipeline/02-03-SUMMARY.md`
</output>
