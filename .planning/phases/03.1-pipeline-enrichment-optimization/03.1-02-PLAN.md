---
phase: 03.1-pipeline-enrichment-optimization
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - scripts/pipeline/lib/recipe-assembler.ts
  - scripts/pipeline/enrich.ts

autonomous: true

must_haves:
  truths:
    - "The new enrich.ts orchestrates a two-stage pipeline: Stage 1 enriches unique ingredients to a reference file, Stage 2 assembles enriched recipes"
    - "Stage 1 reads scraped JSONL, extracts unique ingredients, batches them by 20, enriches via Claude CLI, writes to ingredient-macros.jsonl"
    - "Stage 2 reads scraped JSONL + ingredient-macros.jsonl, joins macros to each recipe's ingredients, writes enriched JSONL in the same EnrichedRecipe format"
    - "Cross-validation against Jow per-serving nutrition is preserved in Stage 2"
    - "The enriched output (jow-recipes-enriched.jsonl) has identical format to the old pipeline -- upload.ts works unchanged"
    - "Both stages are resumable: Stage 1 skips already-enriched ingredients, Stage 2 skips already-assembled recipes"
  artifacts:
    - path: "scripts/pipeline/lib/recipe-assembler.ts"
      provides: "assembleEnrichedRecipe function and loadMacroLookup for Stage 2"
      exports: ["assembleEnrichedRecipe", "loadMacroLookup"]
    - path: "scripts/pipeline/enrich.ts"
      provides: "Two-stage enrichment pipeline orchestrator"
  key_links:
    - from: "scripts/pipeline/lib/recipe-assembler.ts"
      to: "scripts/pipeline/lib/claude-enricher.ts"
      via: "crossValidateNutrition for Stage 2 validation"
      pattern: "crossValidateNutrition"
    - from: "scripts/pipeline/enrich.ts"
      to: "scripts/pipeline/lib/ingredient-extractor.ts"
      via: "extractUniqueIngredients for Stage 1"
      pattern: "extractUniqueIngredients"
    - from: "scripts/pipeline/enrich.ts"
      to: "scripts/pipeline/lib/claude-enricher.ts"
      via: "enrichIngredientBatchWithRetry for Stage 1"
      pattern: "enrichIngredientBatchWithRetry"
    - from: "scripts/pipeline/enrich.ts"
      to: "scripts/pipeline/lib/recipe-assembler.ts"
      via: "assembleEnrichedRecipe + loadMacroLookup for Stage 2"
      pattern: "assembleEnrichedRecipe"
    - from: "scripts/pipeline/enrich.ts"
      to: "data/enriched/ingredient-macros.jsonl"
      via: "JSONL reference file written by Stage 1, read by Stage 2"
---

<objective>
Build the recipe assembler (Stage 2) and rewrite the enrich.ts orchestrator as a two-stage pipeline: (1) batch-enrich unique ingredients to a reference file, (2) assemble enriched recipes by joining ingredient macros back to recipes.

Purpose: This completes the optimization. The new pipeline makes ~47 Claude CLI calls instead of ~3213, reducing enrichment time from ~27 hours to ~24 minutes while producing identical output for the upload pipeline.

Output: New `recipe-assembler.ts` module and rewritten `enrich.ts` that orchestrates both stages with resumability, cross-validation, and progress logging.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-pipeline-enrichment-optimization/03.1-RESEARCH.md
@.planning/phases/03.1-pipeline-enrichment-optimization/03.1-01-SUMMARY.md

@scripts/pipeline/lib/types.ts
@scripts/pipeline/lib/schemas.ts
@scripts/pipeline/lib/ingredient-extractor.ts
@scripts/pipeline/lib/claude-enricher.ts
@scripts/pipeline/lib/jsonl.ts
@scripts/pipeline/lib/logger.ts
@scripts/pipeline/enrich.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create recipe assembler module (Stage 2 core)</name>
  <files>scripts/pipeline/lib/recipe-assembler.ts</files>
  <action>
Create `scripts/pipeline/lib/recipe-assembler.ts` with the following exports:

1. `loadMacroLookup(macrosPath: string): Promise<Map<string, EnrichedIngredient>>`
   - Read all entries from `ingredient-macros.jsonl` using `readJsonl`
   - Build a `Map<string, EnrichedIngredient>` keyed by exact ingredient name (no normalization -- Jow names are consistent, research confirmed 0 case-only duplicates)
   - Return the map

2. `assembleEnrichedRecipe(recipe: ScrapedRecipe, macroLookup: Map<string, EnrichedIngredient>): { enriched: EnrichedRecipe; missingIngredients: string[] } | null`
   - For each ingredient in `recipe.ingredients`, look up macros from `macroLookup` by `ing.name`
   - Track missing ingredients (names not found in lookup)
   - If ALL ingredients are missing, return null (recipe cannot be assembled)
   - If SOME ingredients are missing, still assemble the recipe but return the list of missing ingredient names for logging. For missing ingredients, omit them from the `enrichedIngredients` array only (do NOT include null macros -- the upload API expects valid EnrichedIngredient objects). The original `recipe.ingredients` array remains untouched -- it is spread into the EnrichedRecipe as-is, preserving all ingredient metadata. Only the `enrichedIngredients` array reflects the subset that had macros available.
   - Build `EnrichedRecipe` object: `{ ...recipe, enrichedIngredients }` where `enrichedIngredients` is the array of looked-up `EnrichedIngredient` objects (may be fewer than recipe.ingredients if some were missing)
   - Return the assembled recipe and list of missing ingredient names. Stage 2 in enrich.ts tracks counts: success (all ingredients found), incomplete (some missing), failed (all missing / null return)

3. Import `crossValidateNutrition` from `./claude-enricher` and re-export it for convenience (Stage 2 will use it during assembly). Alternatively, the orchestrator can import it directly -- either approach is fine, but document the choice.

4. Import types from `./types`: `EnrichedIngredient`, `EnrichedRecipe`, `ScrapedRecipe`
   Import `readJsonl` from `./jsonl`
  </action>
  <verify>
Run `pnpm check` to confirm no lint/format errors. Verify imports:
```bash
pnpm tsx -e "import { loadMacroLookup, assembleEnrichedRecipe } from './scripts/pipeline/lib/recipe-assembler'; console.log('OK')"
```
  </verify>
  <done>
`loadMacroLookup` reads ingredient-macros.jsonl into a Map. `assembleEnrichedRecipe` joins ingredient macros to a scraped recipe, tracks missing ingredients, and returns an EnrichedRecipe in the exact format the upload pipeline expects.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite enrich.ts as two-stage pipeline orchestrator</name>
  <files>scripts/pipeline/enrich.ts</files>
  <action>
Replace the contents of `scripts/pipeline/enrich.ts` with a two-stage pipeline orchestrator. Keep the same CLI argument parsing pattern but adapt for the new flow.

**CLI arguments:**
- `--input` (default: `data/scraped/jow-recipes.jsonl`) -- scraped recipes input
- `--output` (default: `data/enriched/jow-recipes-enriched.jsonl`) -- enriched recipes output
- `--macros` (default: `data/enriched/ingredient-macros.jsonl`) -- ingredient reference file
- `--limit` (default: unlimited) -- limit number of ingredients to enrich in Stage 1 (for testing)
- `--batch-size` (default: 20) -- number of ingredients per Claude CLI call
- `--no-delay` -- skip the 5s confirmation delay
- `--stage` (optional: `1`, `2`, or omitted for both) -- run only Stage 1, only Stage 2, or both (default: both sequentially)

**Stage 1: Enrich Unique Ingredients**
1. Call `extractUniqueIngredients(inputPath)` to get sorted unique names
2. Load existing reference file (`macrosPath`) to build a Set of already-enriched ingredient names (resumability)
3. Filter out already-enriched names
4. Apply `--limit` if set
5. Show cost awareness: "This will call Claude CLI for N batches of M ingredients"
6. Wait 5s unless `--no-delay`
7. Batch the remaining ingredients into groups of `batchSize`
8. For each batch:
   - Log progress: `[batch X/Y] Enriching N ingredients...`
   - Call `enrichIngredientBatchWithRetry(batch)`
   - For each returned ingredient, append to `macrosPath` via `appendJsonl`
   - Log flagged batches
   - Track success/flagged/failed counts
9. Log Stage 1 summary

**Stage 2: Assemble Enriched Recipes**
1. Call `loadMacroLookup(macrosPath)` to load the reference file
2. Log: "Loaded N ingredient macros from reference file"
3. Build resumability set: read existing enriched JSONL to get already-assembled jowIds
4. Read all scraped recipes, filter out already-assembled ones
5. For each recipe:
   - Call `assembleEnrichedRecipe(recipe, macroLookup)`
   - If null (all ingredients missing), log error and count as failed
   - If has missing ingredients, log warning with names
   - Call `crossValidateNutrition(enrichedRecipe.enrichedIngredients, recipe)` for quality check (import `crossValidateNutrition` from `./lib/claude-enricher` at the top of the file alongside `enrichIngredientBatchWithRetry`)
   - Build flags array: `_flags` if cross-validation fails
   - Append to output JSONL
   - Track success/flagged/failed/incomplete counts
6. Log Stage 2 summary with completeness stats (how many recipes had all ingredients vs partial)

**Main function flow:**
```
if stage is "1" or undefined: run Stage 1
if stage is "2" or undefined: run Stage 2
```

**Logging:** Use `createLogger("enrich")` for both stages. Prefix Stage 1 logs with `[Stage 1]` and Stage 2 logs with `[Stage 2]`.

**Important details:**
- Ensure output directories exist (mkdirSync recursive) before writing
- The `--stage 2` flag allows re-running assembly without re-enriching (useful if enrichment is complete but assembly needs tweaking)
- Cross-validation is moved from the old per-recipe enrichment loop to Stage 2 assembly (it needs both enriched macros AND recipe data to compare against Jow nutrition)

**Complexity note:** This task rewrites enrich.ts with two stages, CLI parsing, and resumability. This is acceptable as a single task because: (1) it is one file, (2) the old enrich.ts is fully replaced (not incrementally modified), and (3) the two stages follow the same structural pattern (read input, process, write JSONL, log stats). Implement Stage 1 loop first, then Stage 2 loop, then wire the main function to call both.
  </action>
  <verify>
1. `pnpm check` passes (Biome lint + format)
2. Dry-run test (no actual Claude calls needed for Stage 2):
   - If ingredient-macros.jsonl exists with some data, run `pnpm tsx scripts/pipeline/enrich.ts --stage 2 --no-delay` and verify it produces enriched JSONL
   - Check that the output format matches EnrichedRecipe (has `enrichedIngredients` array)
3. Verify CLI help output makes sense: run with just `--help` flag (or print usage on invalid args)
4. Verify the `--stage 1 --limit 1 --batch-size 1` flags work for a minimal test run (this will make 1 Claude CLI call for 1 ingredient)
  </verify>
  <done>
The new `enrich.ts` orchestrates a two-stage pipeline:
- Stage 1: extracts unique ingredients, batch-enriches via Claude CLI (batches of 20), writes to ingredient-macros.jsonl with resumability
- Stage 2: loads macro reference, assembles enriched recipes by joining macros to scraped recipes, cross-validates against Jow nutrition, writes enriched JSONL
- Both stages are resumable and produce identical output format for the upload pipeline
- CLI flags: --input, --output, --macros, --limit, --batch-size, --no-delay, --stage
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes (Biome lint + format)
2. `pnpm tsx scripts/pipeline/enrich.ts --stage 1 --limit 1 --batch-size 1 --no-delay` runs Stage 1 for 1 ingredient (1 Claude CLI call)
3. `data/enriched/ingredient-macros.jsonl` contains 1 valid entry after Stage 1 test
4. `pnpm tsx scripts/pipeline/enrich.ts --stage 2 --no-delay` runs Stage 2 and produces enriched JSONL
5. The enriched JSONL entries have the `enrichedIngredients` array matching `EnrichedIngredient` interface
6. Cross-validation flags (`_flags`) are applied when Jow nutrition diverges
7. Resumability: re-running Stage 1 skips already-enriched ingredients; re-running Stage 2 skips already-assembled recipes
8. The upload script (`scripts/pipeline/upload.ts`) can read the new enriched JSONL without changes
</verification>

<success_criteria>
- Two-stage pipeline orchestrator replaces per-recipe enrichment
- Stage 1 produces ingredient-macros.jsonl reference file via batch Claude CLI calls
- Stage 2 produces jow-recipes-enriched.jsonl in identical EnrichedRecipe format
- Cross-validation preserved in Stage 2
- Both stages resumable (skip already-processed items)
- Upload pipeline works unchanged with new output
- ~47 Claude CLI calls instead of ~3213 (batch of 20, 924 unique ingredients)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-pipeline-enrichment-optimization/03.1-02-SUMMARY.md`
</output>
