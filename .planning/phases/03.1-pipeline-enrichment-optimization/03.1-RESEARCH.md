# Phase 3.1: Pipeline Enrichment Optimization - Research

**Researched:** 2026-02-08
**Domain:** Data pipeline optimization -- ingredient deduplication and batch enrichment via Claude CLI
**Confidence:** HIGH

## Summary

The current enrichment pipeline (`scripts/pipeline/enrich.ts`) makes one Claude CLI call per recipe (~3213 recipes), each taking ~15-17 seconds. With 3213 recipes this would take ~26.8 hours. Analysis of the 3213 scraped recipes reveals only **924 unique ingredient names** across **19,239 total ingredient occurrences** (average 20.8 occurrences per ingredient). The optimization is to extract all unique ingredients, enrich each once, store the results in a reference file, then map macros back to all recipes that use each ingredient.

The approach is straightforward: no new libraries needed. The existing pipeline infrastructure (JSONL read/write, Claude CLI wrapper, Zod validation, logger) is fully reusable. The new pipeline replaces the per-recipe enrichment loop with a two-phase process: (1) enrich unique ingredients to a reference file, (2) assemble enriched recipes by looking up ingredient macros from the reference.

Batching multiple ingredients per Claude CLI call (e.g., 20-50 per call) further reduces total calls from 924 to ~19-47, cutting total enrichment time from hours to minutes.

**Primary recommendation:** Replace per-recipe enrichment with a two-stage pipeline: (1) extract and batch-enrich unique ingredients to `data/enriched/ingredient-macros.jsonl`, (2) assemble enriched recipes by joining scraped recipes with the ingredient reference file. Batch 20 ingredients per Claude CLI call for ~47 calls total.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Node.js fs/readline | built-in | JSONL file I/O | Already used in `scripts/pipeline/lib/jsonl.ts` |
| Zod | 3.25.x | Validation of enriched ingredient macros | Already used in `scripts/pipeline/lib/schemas.ts` |
| Claude CLI | current | LLM enrichment via `claude -p` | Already used in `scripts/pipeline/lib/claude-enricher.ts` |
| tsx | 4.21.x | TypeScript execution | Already used for all pipeline scripts |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| (none) | - | - | No new libraries needed |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| JSONL reference file | SQLite local DB | Overkill for 924 records; JSONL is simpler, consistent with existing pipeline |
| Batch 20/call | Single ingredient/call | 924 calls vs 47 -- batching saves ~95% of time |
| Batch 50/call | Batch 20/call | Larger batches risk output truncation or quality degradation; 20 is a safe sweet spot |

**Installation:**
```bash
# No new packages needed -- all infrastructure exists
```

## Architecture Patterns

### Recommended Pipeline Structure

The new pipeline replaces the single `enrich.ts` script with a two-stage process. File structure within existing `scripts/pipeline/`:

```
scripts/pipeline/
  enrich.ts                          # REPLACED: now orchestrates both stages
  lib/
    claude-enricher.ts               # MODIFIED: add batch enrichment function
    ingredient-extractor.ts          # NEW: extract unique ingredients from scraped JSONL
    recipe-assembler.ts              # NEW: join ingredient macros back to recipes
    types.ts                         # MODIFIED: add IngredientMacro type
    schemas.ts                       # MODIFIED: add ingredientMacroSchema
    jsonl.ts                         # UNCHANGED
    logger.ts                        # UNCHANGED
  prompts/
    macro-enrichment.md              # MODIFIED: adapted for ingredient-list input (not recipe)
data/
  scraped/jow-recipes.jsonl          # UNCHANGED (input)
  enriched/
    ingredient-macros.jsonl          # NEW: reference file (924 entries)
    jow-recipes-enriched.jsonl       # OUTPUT (same format as before)
```

### Pattern 1: Two-Stage Enrichment Pipeline
**What:** Stage 1 enriches unique ingredients; Stage 2 assembles enriched recipes
**When to use:** When many recipes share ingredients (deduplication ratio > 3:1)
**Example:**
```
Stage 1: Extract & Enrich
  scraped JSONL -> extract unique names -> batch into groups of 20
  -> Claude CLI call per batch -> validate with Zod -> write ingredient-macros.jsonl

Stage 2: Assemble
  scraped JSONL + ingredient-macros.jsonl -> lookup macros per ingredient
  -> build EnrichedRecipe objects -> write enriched JSONL
```

### Pattern 2: Batch Ingredient Enrichment
**What:** Send N ingredients per Claude CLI call instead of per-recipe
**When to use:** When enriching standalone ingredients without recipe context
**Key insight:** Ingredient macros per 100g are intrinsic properties (e.g., "chicken breast" is always ~31g protein/100g regardless of which recipe it appears in). No recipe context needed for nutritional estimation.
**Example:**
```typescript
// Input to Claude CLI: list of ingredient names
{
  "ingredients": [
    { "name": "Poulet (escalope)" },
    { "name": "Riz" },
    { "name": "Brocoli (frais)" },
    // ... up to 20 per batch
  ]
}

// Output from Claude CLI: same structure as before
{
  "ingredients": [
    { "name": "Poulet (escalope)", "proteinPer100g": 31, "carbsPer100g": 0, "fatPer100g": 3.6, "caloriesPer100g": 165, "confidence": "high" },
    // ...
  ]
}
```

### Pattern 3: Reference File with Resumability
**What:** `ingredient-macros.jsonl` serves as the reference file. Already-enriched ingredients are skipped on re-run.
**When to use:** For resumable, idempotent pipeline stages
**Key constraint:** The existing enriched recipe output format (`data/enriched/jow-recipes-enriched.jsonl`) MUST remain identical. The upload script and API endpoint expect `EnrichedRecipe` with `enrichedIngredients[]` per recipe. Stage 2 must produce this exact format.

### Anti-Patterns to Avoid
- **Re-enriching per recipe:** The entire point of this phase. Each Claude call costs tokens and time.
- **Losing cross-validation:** The current pipeline cross-validates Claude's estimates against Jow per-serving nutrition. This must be preserved in Stage 2 (assembly), not Stage 1 (ingredient enrichment).
- **Changing the upload format:** The enriched JSONL format and upload API endpoint must remain compatible. Stage 2 output must match `EnrichedRecipe` exactly.
- **Normalizing ingredient names prematurely:** Analysis shows no case-only duplicates in the 924 names. Jow ingredient names are consistent. Do NOT add fuzzy matching or normalization -- it would be premature and could introduce errors.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| JSONL read/write | New file utilities | Existing `scripts/pipeline/lib/jsonl.ts` | Already tested, handles edge cases |
| Zod validation | Manual bounds checking | Existing `enrichedIngredientSchema` from `schemas.ts` | Already defines correct bounds |
| Claude CLI invocation | New CLI wrapper | Extend existing `claude-enricher.ts` with batch function | Same temp file pattern, same output parsing |
| Progress logging | Custom console.log | Existing `createLogger()` from `logger.ts` | Consistent log format and file output |

**Key insight:** The existing infrastructure from Phase 2 covers 90% of what's needed. The optimization is a structural change in data flow, not new technology.

## Common Pitfalls

### Pitfall 1: Ingredient Name Mismatch Between Stages
**What goes wrong:** Stage 1 enriches "Poulet (escalope)" but Stage 2 looks up "poulet (escalope)" and finds nothing.
**Why it happens:** Case sensitivity in Map lookups when joining ingredient macros to recipes.
**How to avoid:** Use exact string match (not lowercased). Analysis confirms Jow names are consistent -- no case-only duplicates exist in the 924 unique names. The scraped data uses the exact same `name` field everywhere.
**Warning signs:** Recipes with missing `enrichedIngredients` in the output, or ingredients with null macros.

### Pitfall 2: Breaking the Enriched Recipe Output Format
**What goes wrong:** Upload script fails because enriched JSONL has different structure.
**Why it happens:** Stage 2 assembly produces a different format than the original per-recipe enrichment.
**How to avoid:** Stage 2 must produce exactly `EnrichedRecipe` (ScrapedRecipe + `enrichedIngredients: EnrichedIngredient[]`). Test by feeding Stage 2 output to `upload.ts` and verifying it works.
**Warning signs:** Upload script validation errors, missing fields.

### Pitfall 3: Batch Size Too Large Causing Quality Degradation
**What goes wrong:** Claude returns inaccurate macros or skips ingredients when batch is too large.
**Why it happens:** Large context = more chances for errors, ingredient names getting confused.
**How to avoid:** Use batch size of 20 (well within context limits, each batch is ~580 chars input). Validate output count matches input count for each batch.
**Warning signs:** Returned ingredient count != input count, or macros that seem obviously wrong (e.g., water with 50g protein).

### Pitfall 4: Forgetting Cross-Validation in New Pipeline
**What goes wrong:** Enriched recipes are no longer cross-validated against Jow per-serving nutrition.
**Why it happens:** Cross-validation was in the per-recipe enrichment loop. The new Stage 2 (assembly) must re-implement it.
**How to avoid:** Move `crossValidateNutrition()` call to Stage 2 (recipe assembly), where both enriched ingredients and recipe data are available.
**Warning signs:** No `_flags` field in output, or validation issues only discovered at upload.

### Pitfall 5: Not Handling Missing Ingredients in Reference
**What goes wrong:** An ingredient exists in a scraped recipe but not in the reference file (e.g., enrichment for that batch failed).
**Why it happens:** Some batches may fail during Stage 1 enrichment. Stage 2 must handle missing ingredients gracefully.
**How to avoid:** Stage 2 should log a warning and either skip the recipe or include it with null macros. Track completeness metrics.
**Warning signs:** Silent data loss where recipes appear enriched but have fewer ingredients than expected.

## Code Examples

### Extracting Unique Ingredients
```typescript
// Source: codebase analysis of data/scraped/jow-recipes.jsonl structure
import { readJsonl } from "./jsonl";
import type { ScrapedRecipe } from "./types";

export async function extractUniqueIngredients(
  scrapedPath: string,
): Promise<string[]> {
  const names = new Set<string>();
  for await (const recipe of readJsonl<ScrapedRecipe>(scrapedPath)) {
    for (const ing of recipe.ingredients) {
      names.add(ing.name);
    }
  }
  return Array.from(names).sort();
}
```

### Batch Enrichment Function
```typescript
// Source: adapted from existing enrichRecipe() in claude-enricher.ts
// Key change: input is a list of ingredient names, not a full recipe
export function enrichIngredientBatch(
  ingredientNames: string[],
): EnrichedIngredient[] {
  const input = {
    ingredients: ingredientNames.map((name) => ({ name })),
  };
  // Same Claude CLI call pattern as enrichRecipe():
  // cat tmpFile | claude -p --system-prompt "..." --output-format json --json-schema "..." --model sonnet --tools ""
  // Parse output, validate with Zod
  // Return EnrichedIngredient[]
}
```

### Recipe Assembly (Stage 2)
```typescript
// Source: join pattern from existing api-client.ts buildUploadPayload()
import type { EnrichedIngredient, EnrichedRecipe, ScrapedRecipe } from "./types";

export function assembleEnrichedRecipe(
  recipe: ScrapedRecipe,
  macroLookup: Map<string, EnrichedIngredient>,
): EnrichedRecipe | null {
  const enrichedIngredients: EnrichedIngredient[] = [];
  for (const ing of recipe.ingredients) {
    const macros = macroLookup.get(ing.name);
    if (!macros) return null; // ingredient not in reference
    enrichedIngredients.push(macros);
  }
  return { ...recipe, enrichedIngredients };
}
```

### Modified Prompt for Ingredient-List Input
```markdown
# Macro Nutrient Estimation

You are a nutrition data specialist. Your task is to estimate macronutrients per 100g
of edible portion for each ingredient in the list below.

## Instructions
(same as existing macro-enrichment.md but adapted:)
- Input is a list of ingredient names (not a recipe)
- Return macros for each ingredient independently
- French ingredient names (from Jow.fr)
- Reference USDA FoodData Central and Table Ciqual/ANSES
```

### New Type: IngredientMacro
```typescript
// For the reference file (ingredient-macros.jsonl)
export interface IngredientMacro {
  name: string;
  proteinPer100g: number;
  carbsPer100g: number;
  fatPer100g: number;
  caloriesPer100g: number;
  confidence: "high" | "medium" | "low";
}
// Note: this is structurally identical to EnrichedIngredient
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| 1 Claude call per recipe (3213 calls) | 1 Claude call per batch of unique ingredients (~47 calls) | Phase 3.1 | ~99% reduction in Claude CLI calls |
| ~26.8 hours enrichment time | ~24 minutes (47 batches x ~30s) | Phase 3.1 | Practical to run the full pipeline |
| Re-enriching shared ingredients | Each ingredient enriched once | Phase 3.1 | Consistent macros across recipes sharing ingredients |

**Deprecated/outdated:**
- The per-recipe enrichment approach in current `enrich.ts` is replaced but the output format is preserved

## Open Questions

1. **Batch size sweet spot**
   - What we know: 20 ingredients per batch = 578 chars input (well within limits). 50 per batch = 1457 chars (still fine).
   - What's unclear: Whether Claude's accuracy degrades at larger batch sizes (50+ ingredients)
   - Recommendation: Start with 20, measure quality. The prompt is simple (ingredient name -> macros), so 20-30 should be safe. Can be tuned later.

2. **Handling already-enriched recipes from the old pipeline**
   - What we know: 8 recipes already enriched in the old format. 30 unique ingredients already have macros.
   - What's unclear: Should we reset the enriched JSONL and start fresh, or preserve the 8 existing entries?
   - Recommendation: Start fresh. The old enrichment was only 8 recipes (test data). Regenerating from the new ingredient reference ensures consistency. Delete `data/enriched/jow-recipes-enriched.jsonl` before running the new pipeline.

3. **Whether to keep backward compatibility with old `enrich.ts` interface**
   - What we know: The old CLI flags (`--limit`, `--no-delay`, `--input`, `--output`) were useful.
   - What's unclear: Whether the new pipeline needs the same flags.
   - Recommendation: Keep `--limit` (for ingredient enrichment batch limit), `--no-delay`, and file path overrides. Add `--batch-size` flag for tuning.

## Data Analysis

### Deduplication Efficiency
| Metric | Value |
|--------|-------|
| Total scraped recipes | 3,213 |
| Total ingredient occurrences | 19,239 |
| Unique ingredient names | 924 |
| Average occurrences per ingredient | 20.8x |
| Max occurrences (Ail) | 647x |
| Ingredients appearing only once | 256 |
| Case-only duplicates | 0 (none) |

### Time Savings Estimate
| Approach | Claude CLI Calls | Est. Time | vs Current |
|----------|-----------------|-----------|------------|
| Current (per recipe) | 3,213 | ~26.8 hours | baseline |
| Per unique ingredient | 924 | ~7.7 hours | -71% |
| Batch of 10 | 93 | ~46 min | -97% |
| **Batch of 20** | **47** | **~24 min** | **-99%** |
| Batch of 50 | 19 | ~10 min | -99.4% |

### Average Ingredients Per Recipe
- Mean: 6.0
- Max: 13
- Min: 1

## Sources

### Primary (HIGH confidence)
- Codebase analysis: `scripts/pipeline/enrich.ts`, `scripts/pipeline/lib/claude-enricher.ts`, `scripts/pipeline/lib/types.ts`, `scripts/pipeline/lib/schemas.ts` -- direct code inspection
- Data analysis: `data/scraped/jow-recipes.jsonl` -- 3213 recipes, 924 unique ingredients extracted
- Timing data: `data/enrich-2026-02-08T19-02-36.log` -- ~15-17s per Claude CLI call observed

### Secondary (MEDIUM confidence)
- Batch size recommendation (20) based on token estimation (~580 chars per 20 ingredients) and Claude context window analysis

### Tertiary (LOW confidence)
- None -- all findings based on direct codebase and data analysis

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - No new libraries, all existing infrastructure reused
- Architecture: HIGH - Two-stage pipeline with JSONL reference file is a straightforward data engineering pattern
- Pitfalls: HIGH - Based on direct code analysis of existing pipeline and data characteristics

**Research date:** 2026-02-08
**Valid until:** 2026-03-10 (stable domain, no external dependency changes expected)
