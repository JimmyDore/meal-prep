---
phase: 03.1-pipeline-enrichment-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/pipeline/lib/types.ts
  - scripts/pipeline/lib/schemas.ts
  - scripts/pipeline/lib/ingredient-extractor.ts
  - scripts/pipeline/lib/claude-enricher.ts
  - scripts/pipeline/prompts/macro-enrichment.md

autonomous: true

must_haves:
  truths:
    - "Unique ingredients can be extracted from scraped JSONL and deduplicated (924 unique from 19,239 occurrences)"
    - "Ingredients are enriched in batches of 20 via a single Claude CLI call per batch"
    - "Each enriched ingredient has validated macros (Zod schema bounds: protein/carbs/fat 0-100, calories 0-900)"
    - "Already-enriched ingredients are skipped on re-run (resumability via reference file)"
  artifacts:
    - path: "scripts/pipeline/lib/types.ts"
      provides: "IngredientMacro type (structurally identical to EnrichedIngredient)"
      contains: "IngredientMacro"
    - path: "scripts/pipeline/lib/schemas.ts"
      provides: "ingredientMacroSchema Zod schema for reference file validation"
      contains: "ingredientMacroSchema"
    - path: "scripts/pipeline/lib/ingredient-extractor.ts"
      provides: "extractUniqueIngredients function that reads scraped JSONL and returns sorted unique names"
      exports: ["extractUniqueIngredients"]
    - path: "scripts/pipeline/lib/claude-enricher.ts"
      provides: "enrichIngredientBatch function for batch Claude CLI calls"
      exports: ["enrichIngredientBatch"]
    - path: "scripts/pipeline/prompts/macro-enrichment.md"
      provides: "Adapted prompt for ingredient-list input (not recipe context)"
  key_links:
    - from: "scripts/pipeline/lib/ingredient-extractor.ts"
      to: "scripts/pipeline/lib/jsonl.ts"
      via: "readJsonl to read scraped JSONL"
      pattern: "readJsonl.*ScrapedRecipe"
    - from: "scripts/pipeline/lib/claude-enricher.ts"
      to: "scripts/pipeline/lib/schemas.ts"
      via: "enrichedIngredientSchema for Zod validation of batch results"
      pattern: "enrichedIngredientSchema"
---

<objective>
Build the Stage 1 infrastructure for ingredient-level enrichment: extract unique ingredients from scraped data, and enrich them in batches of 20 via Claude CLI with Zod validation and resumability.

Purpose: This is the foundation for the optimized pipeline. Instead of 3213 Claude CLI calls (one per recipe), we extract 924 unique ingredient names and enrich them in ~47 batch calls. This plan creates the extraction, batch enrichment, and validation layer.

Output: New `ingredient-extractor.ts` module, extended `claude-enricher.ts` with batch function, updated types/schemas, and adapted prompt file.
</objective>

<execution_context>
@/Users/jimmydore/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jimmydore/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-pipeline-enrichment-optimization/03.1-RESEARCH.md

@scripts/pipeline/lib/types.ts
@scripts/pipeline/lib/schemas.ts
@scripts/pipeline/lib/claude-enricher.ts
@scripts/pipeline/lib/jsonl.ts
@scripts/pipeline/prompts/macro-enrichment.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IngredientMacro type, schema, and ingredient extractor</name>
  <files>
    scripts/pipeline/lib/types.ts
    scripts/pipeline/lib/schemas.ts
    scripts/pipeline/lib/ingredient-extractor.ts
  </files>
  <action>
1. In `scripts/pipeline/lib/types.ts`, add the `IngredientMacro` interface after `EnrichedIngredient`. It is structurally identical to `EnrichedIngredient` (name, proteinPer100g, carbsPer100g, fatPer100g, caloriesPer100g, confidence) but semantically represents a standalone ingredient enrichment (not tied to a recipe). Export it.

2. In `scripts/pipeline/lib/schemas.ts`, add `ingredientMacroSchema` after `enrichedIngredientSchema`. It uses the same Zod definition as `enrichedIngredientSchema` (protein/carbs/fat 0-100, calories 0-900, confidence enum). Export it. Also export a type `IngredientMacroSchema = z.infer<typeof ingredientMacroSchema>`.

3. Create `scripts/pipeline/lib/ingredient-extractor.ts`:
   - Import `readJsonl` from `./jsonl` and `ScrapedRecipe` from `./types`
   - Export `async function extractUniqueIngredients(scrapedPath: string): Promise<string[]>`
     - Read all recipes from the scraped JSONL
     - Collect all ingredient names into a Set to achieve deduplication -- Set automatically handles duplicate names (exact string match, no normalization needed -- Jow names are consistent with 0 case-only duplicates as confirmed in research)
     - Return `Array.from(names).sort()` for deterministic ordering
   - This is a simple utility -- no Claude CLI calls, no validation, just extraction
  </action>
  <verify>
Run `pnpm check` to confirm no lint/format errors. Verify the new files import correctly:
```bash
pnpm tsx -e "import { extractUniqueIngredients } from './scripts/pipeline/lib/ingredient-extractor'; console.log('OK')"
pnpm tsx -e "import { ingredientMacroSchema } from './scripts/pipeline/lib/schemas'; console.log('OK')"
```
  </verify>
  <done>
IngredientMacro type and ingredientMacroSchema are exported. extractUniqueIngredients reads scraped JSONL and returns sorted unique ingredient names. All files pass Biome lint.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add batch enrichment function and update prompt</name>
  <files>
    scripts/pipeline/lib/claude-enricher.ts
    scripts/pipeline/prompts/macro-enrichment.md
  </files>
  <action>
1. Update `scripts/pipeline/prompts/macro-enrichment.md` to work for both recipe-context and ingredient-list inputs. Replace the "Input Format" section to state:
   - You will receive a JSON object with an `ingredients` array
   - Each entry has a `name` field (French ingredient name from Jow.fr)
   - Return macros for each ingredient independently based on its name
   - Keep the rest of the prompt identical (instructions 1-7 are already ingredient-focused)
   - The key change: remove the phrase "describing a recipe with its ingredients list" and replace with "containing a list of ingredient names"

2. In `scripts/pipeline/lib/claude-enricher.ts`, add a new exported function `enrichIngredientBatch`:

```typescript
export function enrichIngredientBatch(
  ingredientNames: string[],
): EnrichedIngredient[] {
```

   - Takes an array of ingredient name strings (batch of up to 20)
   - Constructs input JSON: `{ ingredients: ingredientNames.map(name => ({ name })) }`
   - Uses the same Claude CLI invocation pattern as existing `enrichRecipe()`:
     - Write input to temp file
     - Write system prompt to temp file (read from macro-enrichment.md)
     - Write JSON schema to temp file
     - `cat tmpFile | claude -p --system-prompt "$(cat promptFile)" --output-format json --json-schema "$(cat schemaFile)" --no-session-persistence --model sonnet --tools ""`
     - Parse output with `parseClaudeOutput()`
     - Validate with `validateIngredients()`
   - IMPORTANT: After validation, check that the returned ingredient count matches the input count. Explicit check: `if (result.length !== ingredientNames.length) throw new Error(\`Expected ${ingredientNames.length} ingredients, got ${result.length}\`)` -- this ensures Claude returned macros for every ingredient in the batch, not a subset
   - Clean up temp files in finally block (same pattern as enrichRecipe)
   - Return the validated `EnrichedIngredient[]`

3. Add a wrapper `enrichIngredientBatchWithRetry` that mirrors `enrichRecipeWithRetry`:
   - First attempt: call `enrichIngredientBatch`, run `boundsCheck`
   - If bounds check fails, retry once
   - If still failing, return with `flagged: true`
   - Return type: `{ ingredients: EnrichedIngredient[]; flagged: boolean }`

4. Keep the existing `enrichRecipe` and `enrichRecipeWithRetry` functions unchanged (they remain for backward compatibility, even if the new pipeline won't use them).

5. Export: `enrichIngredientBatch`, `enrichIngredientBatchWithRetry` (add to existing exports). Keep existing exports unchanged.
  </action>
  <verify>
1. Run `pnpm check` to confirm no lint/format errors.
2. Verify new exports are accessible:
```bash
pnpm tsx -e "import { enrichIngredientBatch, enrichIngredientBatchWithRetry } from './scripts/pipeline/lib/claude-enricher'; console.log('OK')"
```
3. Verify the updated prompt file no longer contains "describing a recipe with its ingredients list" and now contains "containing a list of ingredient names".
4. End-to-end smoke test -- call enrichIngredientBatch with a small batch of 2 ingredients to confirm the full flow (Claude CLI call, parse, validate, count check):
```bash
pnpm tsx -e "
import { enrichIngredientBatch } from './scripts/pipeline/lib/claude-enricher';
const result = enrichIngredientBatch(['Poulet', 'Riz']);
console.log('Got', result.length, 'ingredients');
console.log(JSON.stringify(result, null, 2));
"
```
This should return 2 EnrichedIngredient objects with valid macros. If Claude CLI is not available in this environment, verify at minimum that the function can be called and throws a meaningful error (not a compile/import error).
  </verify>
  <done>
`enrichIngredientBatch` sends a batch of ingredient names to Claude CLI, validates the output count matches input count, validates macros with Zod, and returns EnrichedIngredient[]. `enrichIngredientBatchWithRetry` adds retry with bounds check. Prompt file updated for ingredient-list input. All existing exports preserved. Biome lint passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm check` passes (Biome lint + format)
2. New type `IngredientMacro` is exported from types.ts
3. New schema `ingredientMacroSchema` is exported from schemas.ts
4. `extractUniqueIngredients` function reads JSONL and returns unique names
5. `enrichIngredientBatch` function accepts string[] and returns EnrichedIngredient[]
6. `enrichIngredientBatchWithRetry` adds retry logic with bounds checking
7. Existing exports (`enrichRecipe`, `enrichRecipeWithRetry`, `crossValidateNutrition`) unchanged
8. Updated prompt works for ingredient-list input
</verification>

<success_criteria>
- The Stage 1 infrastructure compiles and passes Biome lint
- extractUniqueIngredients can read the scraped JSONL and return 924 unique names
- enrichIngredientBatch sends batched ingredient names to Claude CLI and validates output
- No existing pipeline functionality is broken (old exports preserved)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-pipeline-enrichment-optimization/03.1-01-SUMMARY.md`
</output>
